#include"LZ77.h"
#include<iostream>
#include<assert.h>
#include<stdlib.h>
#pragma warning(disable:4996)
LZ77::LZ77()
	:_pwin(new UCH[WSIZE*2])
	,_ht(WSIZE){}
LZ77::~LZ77() {
	delete[] _pwin;
	_pwin = nullptr;
}
void LZ77::compressfile(const std::string & strfilepath) {
	//如果源文件小于MIN_MATCH ，则不处理
	//获取文件大小
	FILE* fin = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin) {
		std::cout << "open false" << std::endl;
		return;
	}
	fseek(fin, 0, SEEK_END);
	ULL filesize = ftell(fin);//源文件的size
	if (filesize <= MIN_MATCH) {
		std::cout << "file small" << std::endl;
		return;
	}
	//从压缩文件读取一个缓冲区的数据
	fseek(fin, 0, SEEK_SET);
	size_t  lookahead = fread(_pwin, 1, 2 * WSIZE, fin);//实际读取多少
	USH start = 0;
	//与查找相关变量
	USH hashaddr = 0;
	USH matchhead = 0;
	USH curmatchlength = 0;
	USH curmatchdist = 0;
	//与写标记相关变量
	UCH chflag = 0;
	UCH bitcount = 0;
	bool islen = false;
	FILE *fout = fopen("2.lzp", "wb");
	assert(fout);
	FILE* foutf = fopen("3.txt", "wb");
	assert(foutf);
	//一个一个字符计算的
	//处理前两个字节
	for (USH i = 0; i < MIN_MATCH - 1; ++i) {
		_ht.hashfunc(hashaddr, _pwin[i]);
	}
	//
	//压缩
	while (lookahead) {
		curmatchdist = 0;
		curmatchlength = 0;
		//1.将当前字符串插入哈希表，并获取匹配头
		_ht.insert(matchhead, _pwin[start + 2],start,hashaddr);
		//2.验证在查找缓冲区中是否找到匹配
		if (matchhead != 0) {
			//找最长匹配,带出长度距离对
			curmatchlength = longestmatch(matchhead, curmatchdist,start);
		}
		if (curmatchlength < MIN_MATCH) {
			//没找到
			//将start位置字符写入压缩文件
			fputc(_pwin[start], fout);
			//写当前原字符对应的标记
			writeflage(foutf,chflag,bitcount,false);
			++start;
			lookahead--;
			
		}
		else {
			//找到了
			//将长度距离对写入压缩文件  
			//先写长度，在写距离。为了和Huffman结合
			UCH chlen = curmatchlength - 3;
			fputc(chlen, fout);//最少是3个，所以用0表示3
			fwrite(&curmatchdist, sizeof(curmatchdist), 1, fout);
			//写标记
			writeflage(foutf, chflag, bitcount, true);
			lookahead -= curmatchlength;//更新先行缓冲区中剩余字节数
			//将已经匹配的字符串按三个一组将其插入到哈希表中
			--curmatchlength;//当前字符串已经插入
			while (curmatchlength) {
				start++;
				_ht.insert(matchhead, _pwin[start+2], start,hashaddr);
				--curmatchlength;
			}
			start++;
		}
		//检测先行缓冲区中剩余字符个数
		if ((lookahead <= MIN_LOOKHEAD)&&(!feof(fin))) {
			fillwindows(fin,lookahead);
		}
	}
	//标记位数不足8位
	if (bitcount > 0 && bitcount < 8) {
		chflag <<= (8 - bitcount);
		fputc(chflag,foutf);
	}
	//将数据文件+标记文件合并
	fflush(foutf);
	mergefile(fout, filesize);
	fclose(fin);
	fclose(fout);
	fclose(foutf);
}
void LZ77::uncompressfile(const std::string & strfilepath) {
	//打开压缩,标记文件指针
	FILE* fin1 = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin1) {
		std::cout << "open false" << std::endl;
		return;
	}
	FILE* fin2 = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin2) {
		std::cout << "open false" << std::endl;
		return;
	}
	//获取源文件大小
	ULL filesize = 0;
	fseek(fin2, 0 - sizeof(filesize), SEEK_END);
	fread(&filesize, sizeof(filesize), 1, fin2);
	//获取标记字节数
	size_t flagsize = 0;
	fseek(fin2, 0 - sizeof(flagsize) - sizeof(filesize), SEEK_END);
	fread(&flagsize, sizeof(flagsize), 1, fin2);
	//将标记指针移动到标记数据的起始位置
	fseek(fin2, 0 - sizeof(flagsize) - flagsize-sizeof(filesize), SEEK_END);
	//开始解压缩
	//写入解压缩数据
	FILE* fout = fopen("4.txt", "wb");
	assert(fout);
	FILE* f = fopen("4.txt", "rb");//读取匹配内容
	if (nullptr == f) {
		std::cout << "open false" << std::endl;
		return;
	}
	UCH bitcount = 0;
	UCH chflag = 0;
	UCH ch = 0;
	UCH matchlen = 0;
	USH matchdist = 0;
	ULL encodecount = 0;
	while (encodecount<filesize) {
		if (bitcount == 0) {
			chflag = fgetc(fin2);
			bitcount = 8;
		}
		if (chflag & 0x80) {
			//是len
			matchlen = fgetc(fin1) + 3;
			encodecount += matchlen;
			fflush(fout);//所以得清空缓冲区
			fread(&matchdist, sizeof(matchdist), 1, fin1);
			//定位文件指针
			fseek(f, 0-matchdist, SEEK_END);
			while (matchlen) {
				//ch为255，因为数据在缓冲区，还没写入
				ch = fgetc(f);
				fputc(ch, fout);
				matchlen--;
			}
		}
		else {
			//原字符
			ch = fgetc(fin1);
			fputc(ch, fout);
			encodecount++;
		}
		chflag <<= 1;
		bitcount--;
	}
	fclose(fin1);
	fclose(fin2);
	fclose(fout);
	fclose(f);
}
void LZ77::mergefile(FILE* fout,ULL filesize) {
	FILE* finf = fopen("3.txt", "rb");
	size_t flagsize = 0;
	UCH* preadbuff = new UCH[1024];
	while (true) {
		size_t rdsize = fread(preadbuff, 1, 1024, finf);
		if (0 == rdsize)
			break;
		fwrite(preadbuff, 1, rdsize, fout);
		flagsize += rdsize;
	}
	fwrite(&flagsize, sizeof(flagsize), 1, fout);
	fwrite(&filesize, sizeof(filesize), 1, fout);
	delete[] preadbuff;
	fclose(finf);
}
void LZ77::fillwindows(FILE* fin,size_t& lookahead){
	//将右窗口数据搬移到左窗口
	memcpy(_pwin, _pwin + WSIZE, WSIZE);

	//更新哈希表
	_ht.update();
	//head prev 中保存的下标
	//大于wsize -wsize
	//小于wsize 置为0
	//读取wsize个数据放置到右窗口
	if (!feof(fin)) {
		lookahead += fread(_pwin + WSIZE, 1, WSIZE, fin);
	}
}
#include"LZ77.h"
#include<iostream>
#include<assert.h>
#include<stdlib.h>
#pragma warning(disable:4996)
LZ77::LZ77()
	:_pwin(new UCH[WSIZE*2])
	,_ht(WSIZE){}
LZ77::~LZ77() {
	delete[] _pwin;
	_pwin = nullptr;
}
void LZ77::compressfile(const std::string & strfilepath) {
	//如果源文件小于MIN_MATCH ，则不处理
	//获取文件大小
	FILE* fin = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin) {
		std::cout << "open false" << std::endl;
		return;
	}
	fseek(fin, 0, SEEK_END);
	ULL filesize = ftell(fin);//源文件的size
	if (filesize <= MIN_MATCH) {
		std::cout << "file small" << std::endl;
		return;
	}
	//从压缩文件读取一个缓冲区的数据
	fseek(fin, 0, SEEK_SET);
	size_t  lookahead = fread(_pwin, 1, 2 * WSIZE, fin);//实际读取多少
	USH start = 0;
	//与查找相关变量
	USH hashaddr = 0;
	USH matchhead = 0;
	USH curmatchlength = 0;
	USH curmatchdist = 0;
	//与写标记相关变量
	UCH chflag = 0;
	UCH bitcount = 0;
	bool islen = false;
	FILE *fout = fopen("2.lzp", "wb");
	assert(fout);
	FILE* foutf = fopen("3.txt", "wb");
	assert(foutf);
	//一个一个字符计算的
	//处理前两个字节
	for (USH i = 0; i < MIN_MATCH - 1; ++i) {
		_ht.hashfunc(hashaddr, _pwin[i]);
	}
	//
	//压缩
	while (lookahead) {
		curmatchdist = 0;
		curmatchlength = 0;
		//1.将当前字符串插入哈希表，并获取匹配头
		_ht.insert(matchhead, _pwin[start + 2],start,hashaddr);
		//2.验证在查找缓冲区中是否找到匹配
		if (matchhead != 0) {
			//找最长匹配,带出长度距离对
			curmatchlength = longestmatch(matchhead, curmatchdist,start);
		}
		if (curmatchlength < MIN_MATCH) {
			//没找到
			//将start位置字符写入压缩文件
			fputc(_pwin[start], fout);
			//写当前原字符对应的标记
			writeflage(foutf,chflag,bitcount,false);
			++start;
			lookahead--;
			
		}
		else {
			//找到了
			//将长度距离对写入压缩文件  
			//先写长度，在写距离。为了和Huffman结合
			UCH chlen = curmatchlength - 3;
			fputc(chlen, fout);//最少是3个，所以用0表示3
			fwrite(&curmatchdist, sizeof(curmatchdist), 1, fout);
			//写标记
			writeflage(foutf, chflag, bitcount, true);
			lookahead -= curmatchlength;//更新先行缓冲区中剩余字节数
			//将已经匹配的字符串按三个一组将其插入到哈希表中
			--curmatchlength;//当前字符串已经插入
			while (curmatchlength) {
				start++;
				_ht.insert(matchhead, _pwin[start+2], start,hashaddr);
				--curmatchlength;
			}
			start++;
		}
		//检测先行缓冲区中剩余字符个数
		if ((lookahead <= MIN_LOOKHEAD)&&(!feof(fin))) {
			fillwindows(fin,lookahead);
		}
	}
	//标记位数不足8位
	if (bitcount > 0 && bitcount < 8) {
		chflag <<= (8 - bitcount);
		fputc(chflag,foutf);
	}
	//将数据文件+标记文件合并
	fflush(foutf);
	mergefile(fout, filesize);
	fclose(fin);
	fclose(fout);
	fclose(foutf);
}
void LZ77::uncompressfile(const std::string & strfilepath) {
	//打开压缩,标记文件指针
	FILE* fin1 = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin1) {
		std::cout << "open false" << std::endl;
		return;
	}
	FILE* fin2 = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin2) {
		std::cout << "open false" << std::endl;
		return;
	}
	//获取源文件大小
	ULL filesize = 0;
	fseek(fin2, 0 - sizeof(filesize), SEEK_END);
	fread(&filesize, sizeof(filesize), 1, fin2);
	//获取标记字节数
	size_t flagsize = 0;
	fseek(fin2, 0 - sizeof(flagsize) - sizeof(filesize), SEEK_END);
	fread(&flagsize, sizeof(flagsize), 1, fin2);
	//将标记指针移动到标记数据的起始位置
	fseek(fin2, 0 - sizeof(flagsize) - flagsize-sizeof(filesize), SEEK_END);
	//开始解压缩
	//写入解压缩数据
	FILE* fout = fopen("4.txt", "wb");
	assert(fout);
	FILE* f = fopen("4.txt", "rb");//读取匹配内容
	if (nullptr == f) {
		std::cout << "open false" << std::endl;
		return;
	}
	UCH bitcount = 0;
	UCH chflag = 0;
	UCH ch = 0;
	UCH matchlen = 0;
	USH matchdist = 0;
	ULL encodecount = 0;
	while (encodecount<filesize) {
		if (bitcount == 0) {
			chflag = fgetc(fin2);
			bitcount = 8;
		}
		if (chflag & 0x80) {
			//是len
			matchlen = fgetc(fin1) + 3;
			encodecount += matchlen;
			fflush(fout);//所以得清空缓冲区
			fread(&matchdist, sizeof(matchdist), 1, fin1);
			//定位文件指针
			fseek(f, 0-matchdist, SEEK_END);
			while (matchlen) {
				//ch为255，因为数据在缓冲区，还没写入
				ch = fgetc(f);
				fputc(ch, fout);
				matchlen--;
			}
		}
		else {
			//原字符
			ch = fgetc(fin1);
			fputc(ch, fout);
			encodecount++;
		}
		chflag <<= 1;
		bitcount--;
	}
	fclose(fin1);
	fclose(fin2);
	fclose(fout);
	fclose(f);
}
void LZ77::mergefile(FILE* fout,ULL filesize) {
	FILE* finf = fopen("3.txt", "rb");
	size_t flagsize = 0;
	UCH* preadbuff = new UCH[1024];
	while (true) {
		size_t rdsize = fread(preadbuff, 1, 1024, finf);
		if (0 == rdsize)
			break;
		fwrite(preadbuff, 1, rdsize, fout);
		flagsize += rdsize;
	}
	fwrite(&flagsize, sizeof(flagsize), 1, fout);
	fwrite(&filesize, sizeof(filesize), 1, fout);
	delete[] preadbuff;
	fclose(finf);
}
void LZ77::fillwindows(FILE* fin,size_t& lookahead){
	//将右窗口数据搬移到左窗口
	memcpy(_pwin, _pwin + WSIZE, WSIZE);

	//更新哈希表
	_ht.update();
	//head prev 中保存的下标
	//大于wsize -wsize
	//小于wsize 置为0
	//读取wsize个数据放置到右窗口
	if (!feof(fin)) {
		lookahead += fread(_pwin + WSIZE, 1, WSIZE, fin);
	}
}
#include"LZ77.h"
#include<iostream>
#include<assert.h>
#include<stdlib.h>
#pragma warning(disable:4996)
LZ77::LZ77()
	:_pwin(new UCH[WSIZE*2])
	,_ht(WSIZE){}
LZ77::~LZ77() {
	delete[] _pwin;
	_pwin = nullptr;
}
void LZ77::compressfile(const std::string & strfilepath) {
	//如果源文件小于MIN_MATCH ，则不处理
	//获取文件大小
	FILE* fin = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin) {
		std::cout << "open false" << std::endl;
		return;
	}
	fseek(fin, 0, SEEK_END);
	ULL filesize = ftell(fin);//源文件的size
	if (filesize <= MIN_MATCH) {
		std::cout << "file small" << std::endl;
		return;
	}
	//从压缩文件读取一个缓冲区的数据
	fseek(fin, 0, SEEK_SET);
	size_t  lookahead = fread(_pwin, 1, 2 * WSIZE, fin);//实际读取多少
	USH start = 0;
	//与查找相关变量
	USH hashaddr = 0;
	USH matchhead = 0;
	USH curmatchlength = 0;
	USH curmatchdist = 0;
	//与写标记相关变量
	UCH chflag = 0;
	UCH bitcount = 0;
	bool islen = false;
	FILE *fout = fopen("2.lzp", "wb");
	assert(fout);
	FILE* foutf = fopen("3.txt", "wb");
	assert(foutf);
	//一个一个字符计算的
	//处理前两个字节
	for (USH i = 0; i < MIN_MATCH - 1; ++i) {
		_ht.hashfunc(hashaddr, _pwin[i]);
	}
	//
	//压缩
	while (lookahead) {
		curmatchdist = 0;
		curmatchlength = 0;
		//1.将当前字符串插入哈希表，并获取匹配头
		_ht.insert(matchhead, _pwin[start + 2],start,hashaddr);
		//2.验证在查找缓冲区中是否找到匹配
		if (matchhead != 0) {
			//找最长匹配,带出长度距离对
			curmatchlength = longestmatch(matchhead, curmatchdist,start);
		}
		if (curmatchlength < MIN_MATCH) {
			//没找到
			//将start位置字符写入压缩文件
			fputc(_pwin[start], fout);
			//写当前原字符对应的标记
			writeflage(foutf,chflag,bitcount,false);
			++start;
			lookahead--;
			
		}
		else {
			//找到了
			//将长度距离对写入压缩文件  
			//先写长度，在写距离。为了和Huffman结合
			UCH chlen = curmatchlength - 3;
			fputc(chlen, fout);//最少是3个，所以用0表示3
			fwrite(&curmatchdist, sizeof(curmatchdist), 1, fout);
			//写标记
			writeflage(foutf, chflag, bitcount, true);
			lookahead -= curmatchlength;//更新先行缓冲区中剩余字节数
			//将已经匹配的字符串按三个一组将其插入到哈希表中
			--curmatchlength;//当前字符串已经插入
			while (curmatchlength) {
				start++;
				_ht.insert(matchhead, _pwin[start+2], start,hashaddr);
				--curmatchlength;
			}
			start++;
		}
		//检测先行缓冲区中剩余字符个数
		if ((lookahead <= MIN_LOOKHEAD)&&(!feof(fin))) {
			fillwindows(fin,lookahead);
		}
	}
	//标记位数不足8位
	if (bitcount > 0 && bitcount < 8) {
		chflag <<= (8 - bitcount);
		fputc(chflag,foutf);
	}
	//将数据文件+标记文件合并
	fflush(foutf);
	mergefile(fout, filesize);
	fclose(fin);
	fclose(fout);
	fclose(foutf);
}
void LZ77::uncompressfile(const std::string & strfilepath) {
	//打开压缩,标记文件指针
	FILE* fin1 = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin1) {
		std::cout << "open false" << std::endl;
		return;
	}
	FILE* fin2 = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin2) {
		std::cout << "open false" << std::endl;
		return;
	}
	//获取源文件大小
	ULL filesize = 0;
	fseek(fin2, 0 - sizeof(filesize), SEEK_END);
	fread(&filesize, sizeof(filesize), 1, fin2);
	//获取标记字节数
	size_t flagsize = 0;
	fseek(fin2, 0 - sizeof(flagsize) - sizeof(filesize), SEEK_END);
	fread(&flagsize, sizeof(flagsize), 1, fin2);
	//将标记指针移动到标记数据的起始位置
	fseek(fin2, 0 - sizeof(flagsize) - flagsize-sizeof(filesize), SEEK_END);
	//开始解压缩
	//写入解压缩数据
	FILE* fout = fopen("4.txt", "wb");
	assert(fout);
	FILE* f = fopen("4.txt", "rb");//读取匹配内容
	if (nullptr == f) {
		std::cout << "open false" << std::endl;
		return;
	}
	UCH bitcount = 0;
	UCH chflag = 0;
	UCH ch = 0;
	UCH matchlen = 0;
	USH matchdist = 0;
	ULL encodecount = 0;
	while (encodecount<filesize) {
		if (bitcount == 0) {
			chflag = fgetc(fin2);
			bitcount = 8;
		}
		if (chflag & 0x80) {
			//是len
			matchlen = fgetc(fin1) + 3;
			encodecount += matchlen;
			fflush(fout);//所以得清空缓冲区
			fread(&matchdist, sizeof(matchdist), 1, fin1);
			//定位文件指针
			fseek(f, 0-matchdist, SEEK_END);
			while (matchlen) {
				//ch为255，因为数据在缓冲区，还没写入
				ch = fgetc(f);
				fputc(ch, fout);
				matchlen--;
			}
		}
		else {
			//原字符
			ch = fgetc(fin1);
			fputc(ch, fout);
			encodecount++;
		}
		chflag <<= 1;
		bitcount--;
	}
	fclose(fin1);
	fclose(fin2);
	fclose(fout);
	fclose(f);
}
void LZ77::mergefile(FILE* fout,ULL filesize) {
	FILE* finf = fopen("3.txt", "rb");
	size_t flagsize = 0;
	UCH* preadbuff = new UCH[1024];
	while (true) {
		size_t rdsize = fread(preadbuff, 1, 1024, finf);
		if (0 == rdsize)
			break;
		fwrite(preadbuff, 1, rdsize, fout);
		flagsize += rdsize;
	}
	fwrite(&flagsize, sizeof(flagsize), 1, fout);
	fwrite(&filesize, sizeof(filesize), 1, fout);
	delete[] preadbuff;
	fclose(finf);
}
void LZ77::fillwindows(FILE* fin,size_t& lookahead){
	//将右窗口数据搬移到左窗口
	memcpy(_pwin, _pwin + WSIZE, WSIZE);

	//更新哈希表
	_ht.update();
	//head prev 中保存的下标
	//大于wsize -wsize
	//小于wsize 置为0
	//读取wsize个数据放置到右窗口
	if (!feof(fin)) {
		lookahead += fread(_pwin + WSIZE, 1, WSIZE, fin);
	}
}
#include"LZ77.h"
#include<iostream>
#include<assert.h>
#include<stdlib.h>
#pragma warning(disable:4996)
LZ77::LZ77()
	:_pwin(new UCH[WSIZE*2])
	,_ht(WSIZE){}
LZ77::~LZ77() {
	delete[] _pwin;
	_pwin = nullptr;
}
void LZ77::compressfile(const std::string & strfilepath) {
	//如果源文件小于MIN_MATCH ，则不处理
	//获取文件大小
	FILE* fin = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin) {
		std::cout << "open false" << std::endl;
		return;
	}
	fseek(fin, 0, SEEK_END);
	ULL filesize = ftell(fin);//源文件的size
	if (filesize <= MIN_MATCH) {
		std::cout << "file small" << std::endl;
		return;
	}
	//从压缩文件读取一个缓冲区的数据
	fseek(fin, 0, SEEK_SET);
	size_t  lookahead = fread(_pwin, 1, 2 * WSIZE, fin);//实际读取多少
	USH start = 0;
	//与查找相关变量
	USH hashaddr = 0;
	USH matchhead = 0;
	USH curmatchlength = 0;
	USH curmatchdist = 0;
	//与写标记相关变量
	UCH chflag = 0;
	UCH bitcount = 0;
	bool islen = false;
	FILE *fout = fopen("2.lzp", "wb");
	assert(fout);
	FILE* foutf = fopen("3.txt", "wb");
	assert(foutf);
	//一个一个字符计算的
	//处理前两个字节
	for (USH i = 0; i < MIN_MATCH - 1; ++i) {
		_ht.hashfunc(hashaddr, _pwin[i]);
	}
	//
	//压缩
	while (lookahead) {
		curmatchdist = 0;
		curmatchlength = 0;
		//1.将当前字符串插入哈希表，并获取匹配头
		_ht.insert(matchhead, _pwin[start + 2],start,hashaddr);
		//2.验证在查找缓冲区中是否找到匹配
		if (matchhead != 0) {
			//找最长匹配,带出长度距离对
			curmatchlength = longestmatch(matchhead, curmatchdist,start);
		}
		if (curmatchlength < MIN_MATCH) {
			//没找到
			//将start位置字符写入压缩文件
			fputc(_pwin[start], fout);
			//写当前原字符对应的标记
			writeflage(foutf,chflag,bitcount,false);
			++start;
			lookahead--;
			
		}
		else {
			//找到了
			//将长度距离对写入压缩文件  
			//先写长度，在写距离。为了和Huffman结合
			UCH chlen = curmatchlength - 3;
			fputc(chlen, fout);//最少是3个，所以用0表示3
			fwrite(&curmatchdist, sizeof(curmatchdist), 1, fout);
			//写标记
			writeflage(foutf, chflag, bitcount, true);
			lookahead -= curmatchlength;//更新先行缓冲区中剩余字节数
			//将已经匹配的字符串按三个一组将其插入到哈希表中
			--curmatchlength;//当前字符串已经插入
			while (curmatchlength) {
				start++;
				_ht.insert(matchhead, _pwin[start+2], start,hashaddr);
				--curmatchlength;
			}
			start++;
		}
		//检测先行缓冲区中剩余字符个数
		if ((lookahead <= MIN_LOOKHEAD)&&(!feof(fin))) {
			fillwindows(fin,lookahead);
		}
	}
	//标记位数不足8位
	if (bitcount > 0 && bitcount < 8) {
		chflag <<= (8 - bitcount);
		fputc(chflag,foutf);
	}
	//将数据文件+标记文件合并
	fflush(foutf);
	mergefile(fout, filesize);
	fclose(fin);
	fclose(fout);
	fclose(foutf);
}
void LZ77::uncompressfile(const std::string & strfilepath) {
	//打开压缩,标记文件指针
	FILE* fin1 = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin1) {
		std::cout << "open false" << std::endl;
		return;
	}
	FILE* fin2 = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin2) {
		std::cout << "open false" << std::endl;
		return;
	}
	//获取源文件大小
	ULL filesize = 0;
	fseek(fin2, 0 - sizeof(filesize), SEEK_END);
	fread(&filesize, sizeof(filesize), 1, fin2);
	//获取标记字节数
	size_t flagsize = 0;
	fseek(fin2, 0 - sizeof(flagsize) - sizeof(filesize), SEEK_END);
	fread(&flagsize, sizeof(flagsize), 1, fin2);
	//将标记指针移动到标记数据的起始位置
	fseek(fin2, 0 - sizeof(flagsize) - flagsize-sizeof(filesize), SEEK_END);
	//开始解压缩
	//写入解压缩数据
	FILE* fout = fopen("4.txt", "wb");
	assert(fout);
	FILE* f = fopen("4.txt", "rb");//读取匹配内容
	if (nullptr == f) {
		std::cout << "open false" << std::endl;
		return;
	}
	UCH bitcount = 0;
	UCH chflag = 0;
	UCH ch = 0;
	UCH matchlen = 0;
	USH matchdist = 0;
	ULL encodecount = 0;
	while (encodecount<filesize) {
		if (bitcount == 0) {
			chflag = fgetc(fin2);
			bitcount = 8;
		}
		if (chflag & 0x80) {
			//是len
			matchlen = fgetc(fin1) + 3;
			encodecount += matchlen;
			fflush(fout);//所以得清空缓冲区
			fread(&matchdist, sizeof(matchdist), 1, fin1);
			//定位文件指针
			fseek(f, 0-matchdist, SEEK_END);
			while (matchlen) {
				//ch为255，因为数据在缓冲区，还没写入
				ch = fgetc(f);
				fputc(ch, fout);
				matchlen--;
			}
		}
		else {
			//原字符
			ch = fgetc(fin1);
			fputc(ch, fout);
			encodecount++;
		}
		chflag <<= 1;
		bitcount--;
	}
	fclose(fin1);
	fclose(fin2);
	fclose(fout);
	fclose(f);
}
void LZ77::mergefile(FILE* fout,ULL filesize) {
	FILE* finf = fopen("3.txt", "rb");
	size_t flagsize = 0;
	UCH* preadbuff = new UCH[1024];
	while (true) {
		size_t rdsize = fread(preadbuff, 1, 1024, finf);
		if (0 == rdsize)
			break;
		fwrite(preadbuff, 1, rdsize, fout);
		flagsize += rdsize;
	}
	fwrite(&flagsize, sizeof(flagsize), 1, fout);
	fwrite(&filesize, sizeof(filesize), 1, fout);
	delete[] preadbuff;
	fclose(finf);
}
void LZ77::fillwindows(FILE* fin,size_t& lookahead){
	//将右窗口数据搬移到左窗口
	memcpy(_pwin, _pwin + WSIZE, WSIZE);

	//更新哈希表
	_ht.update();
	//head prev 中保存的下标
	//大于wsize -wsize
	//小于wsize 置为0
	//读取wsize个数据放置到右窗口
	if (!feof(fin)) {
		lookahead += fread(_pwin + WSIZE, 1, WSIZE, fin);
	}#include"LZ77.h"
#include<iostream>
#include<assert.h>
#include<stdlib.h>
#pragma warning(disable:4996)
LZ77::LZ77()
	:_pwin(new UCH[WSIZE*2])
	,_ht(WSIZE){}
LZ77::~LZ77() {
	delete[] _pwin;
	_pwin = nullptr;
}
void LZ77::compressfile(const std::string & strfilepath) {
	//如果源文件小于MIN_MATCH ，则不处理
	//获取文件大小
	FILE* fin = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin) {
		std::cout << "open false" << std::endl;
		return;
	}
	fseek(fin, 0, SEEK_END);
	ULL filesize = ftell(fin);//源文件的size
	if (filesize <= MIN_MATCH) {
		std::cout << "file small" << std::endl;
		return;
	}
	//从压缩文件读取一个缓冲区的数据
	fseek(fin, 0, SEEK_SET);
	size_t  lookahead = fread(_pwin, 1, 2 * WSIZE, fin);//实际读取多少
	USH start = 0;
	//与查找相关变量
	USH hashaddr = 0;
	USH matchhead = 0;
	USH curmatchlength = 0;
	USH curmatchdist = 0;
	//与写标记相关变量
	UCH chflag = 0;
	UCH bitcount = 0;
	bool islen = false;
	FILE *fout = fopen("2.lzp", "wb");
	assert(fout);
	FILE* foutf = fopen("3.txt", "wb");
	assert(foutf);
	//一个一个字符计算的
	//处理前两个字节
	for (USH i = 0; i < MIN_MATCH - 1; ++i) {
		_ht.hashfunc(hashaddr, _pwin[i]);
	}
	//
	//压缩
	while (lookahead) {
		curmatchdist = 0;
		curmatchlength = 0;
		//1.将当前字符串插入哈希表，并获取匹配头
		_ht.insert(matchhead, _pwin[start + 2],start,hashaddr);
		//2.验证在查找缓冲区中是否找到匹配
		if (matchhead != 0) {
			//找最长匹配,带出长度距离对
			curmatchlength = longestmatch(matchhead, curmatchdist,start);
		}
		if (curmatchlength < MIN_MATCH) {
			//没找到
			//将start位置字符写入压缩文件
			fputc(_pwin[start], fout);
			//写当前原字符对应的标记
			writeflage(foutf,chflag,bitcount,false);
			++start;
			lookahead--;
			
		}
		else {
			//找到了
			//将长度距离对写入压缩文件  
			//先写长度，在写距离。为了和Huffman结合
			UCH chlen = curmatchlength - 3;
			fputc(chlen, fout);//最少是3个，所以用0表示3
			fwrite(&curmatchdist, sizeof(curmatchdist), 1, fout);
			//写标记
			writeflage(foutf, chflag, bitcount, true);
			lookahead -= curmatchlength;//更新先行缓冲区中剩余字节数
			//将已经匹配的字符串按三个一组将其插入到哈希表中
			--curmatchlength;//当前字符串已经插入
			while (curmatchlength) {
				start++;
				_ht.insert(matchhead, _pwin[start+2], start,hashaddr);
				--curmatchlength;
			}
			start++;
		}
		//检测先行缓冲区中剩余字符个数
		if ((lookahead <= MIN_LOOKHEAD)&&(!feof(fin))) {
			fillwindows(fin,lookahead);
		}
	}
	//标记位数不足8位
	if (bitcount > 0 && bitcount < 8) {
		chflag <<= (8 - bitcount);
		fputc(chflag,foutf);
	}
	//将数据文件+标记文件合并
	fflush(foutf);
	mergefile(fout, filesize);
	fclose(fin);
	fclose(fout);
	fclose(foutf);
}
void LZ77::uncompressfile(const std::string & strfilepath) {
	//打开压缩,标记文件指针
	FILE* fin1 = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin1) {
		std::cout << "open false" << std::endl;
		return;
	}
	FILE* fin2 = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin2) {
		std::cout << "open false" << std::endl;
		return;
	}
	//获取源文件大小
	ULL filesize = 0;
	fseek(fin2, 0 - sizeof(filesize), SEEK_END);
	fread(&filesize, sizeof(filesize), 1, fin2);
	//获取标记字节数
	size_t flagsize = 0;
	fseek(fin2, 0 - sizeof(flagsize) - sizeof(filesize), SEEK_END);
	fread(&flagsize, sizeof(flagsize), 1, fin2);
	//将标记指针移动到标记数据的起始位置
	fseek(fin2, 0 - sizeof(flagsize) - flagsize-sizeof(filesize), SEEK_END);
	//开始解压缩
	//写入解压缩数据
	FILE* fout = fopen("4.txt", "wb");
	assert(fout);
	FILE* f = fopen("4.txt", "rb");//读取匹配内容
	if (nullptr == f) {
		std::cout << "open false" << std::endl;
		return;
	}
	UCH bitcount = 0;
	UCH chflag = 0;
	UCH ch = 0;
	UCH matchlen = 0;
	USH matchdist = 0;
	ULL encodecount = 0;
	while (encodecount<filesize) {
		if (bitcount == 0) {
			chflag = fgetc(fin2);
			bitcount = 8;
		}
		if (chflag & 0x80) {
			//是len
			matchlen = fgetc(fin1) + 3;
			encodecount += matchlen;
			fflush(fout);//所以得清空缓冲区
			fread(&matchdist, sizeof(matchdist), 1, fin1);
			//定位文件指针
			fseek(f, 0-matchdist, SEEK_END);
			while (matchlen) {
				//ch为255，因为数据在缓冲区，还没写入
				ch = fgetc(f);
				fputc(ch, fout);
				matchlen--;
			}
		}
		else {
			//原字符
			ch = fgetc(fin1);
			fputc(ch, fout);
			encodecount++;
		}
		chflag <<= 1;
		bitcount--;
	}
	fclose(fin1);
	fclose(fin2);
	fclose(fout);
	fclose(f);
}
void LZ77::mergefile(FILE* fout,ULL filesize) {
	FILE* finf = fopen("3.txt", "rb");
	size_t flagsize = 0;
	UCH* preadbuff = new UCH[1024];
	while (true) {
		size_t rdsize = fread(preadbuff, 1, 1024, finf);
		if (0 == rdsize)
			break;
		fwrite(preadbuff, 1, rdsize, fout);
		flagsize += rdsize;
	}
	fwrite(&flagsize, sizeof(flagsize), 1, fout);
	fwrite(&filesize, sizeof(filesize), 1, fout);
	delete[] preadbuff;
	fclose(finf);
}
void LZ77::fillwindows(FILE* fin,size_t& lookahead){
	//将右窗口数据搬移到左窗口
	memcpy(_pwin, _pwin + WSIZE, WSIZE);

	//更新哈希表
	_ht.update();
	//head prev 中保存的下标
	//大于wsize -wsize
	//小于wsize 置为0
	//读取wsize个数据放置到右窗口
	if (!feof(fin)) {
		lookahead += fread(_pwin + WSIZE, 1, WSIZE, fin);
	}
}
#include"LZ77.h"
#include<iostream>
#include<assert.h>
#include<stdlib.h>
#pragma warning(disable:4996)
LZ77::LZ77()
	:_pwin(new UCH[WSIZE*2])
	,_ht(WSIZE){}
LZ77::~LZ77() {
	delete[] _pwin;
	_pwin = nullptr;
}
void LZ77::compressfile(const std::string & strfilepath) {
	//如果源文件小于MIN_MATCH ，则不处理
	//获取文件大小
	FILE* fin = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin) {
		std::cout << "open false" << std::endl;
		return;
	}
	fseek(fin, 0, SEEK_END);
	ULL filesize = ftell(fin);//源文件的size
	if (filesize <= MIN_MATCH) {
		std::cout << "file small" << std::endl;
		return;
	}
	//从压缩文件读取一个缓冲区的数据
	fseek(fin, 0, SEEK_SET);
	size_t  lookahead = fread(_pwin, 1, 2 * WSIZE, fin);//实际读取多少
	USH start = 0;
	//与查找相关变量
	USH hashaddr = 0;
	USH matchhead = 0;
	USH curmatchlength = 0;
	USH curmatchdist = 0;
	//与写标记相关变量
	UCH chflag = 0;
	UCH bitcount = 0;
	bool islen = false;
	FILE *fout = fopen("2.lzp", "wb");
	assert(fout);
	FILE* foutf = fopen("3.txt", "wb");
	assert(foutf);
	//一个一个字符计算的
	//处理前两个字节
	for (USH i = 0; i < MIN_MATCH - 1; ++i) {
		_ht.hashfunc(hashaddr, _pwin[i]);
	}
	//
	//压缩
	while (lookahead) {
		curmatchdist = 0;
		curmatchlength = 0;
		//1.将当前字符串插入哈希表，并获取匹配头
		_ht.insert(matchhead, _pwin[start + 2],start,hashaddr);
		//2.验证在查找缓冲区中是否找到匹配
		if (matchhead != 0) {
			//找最长匹配,带出长度距离对
			curmatchlength = longestmatch(matchhead, curmatchdist,start);
		}
		if (curmatchlength < MIN_MATCH) {
			//没找到
			//将start位置字符写入压缩文件
			fputc(_pwin[start], fout);
			//写当前原字符对应的标记
			writeflage(foutf,chflag,bitcount,false);
			++start;
			lookahead--;
			
		}
		else {
			//找到了
			//将长度距离对写入压缩文件  
			//先写长度，在写距离。为了和Huffman结合
			UCH chlen = curmatchlength - 3;
			fputc(chlen, fout);//最少是3个，所以用0表示3
			fwrite(&curmatchdist, sizeof(curmatchdist), 1, fout);
			//写标记
			writeflage(foutf, chflag, bitcount, true);
			lookahead -= curmatchlength;//更新先行缓冲区中剩余字节数
			//将已经匹配的字符串按三个一组将其插入到哈希表中
			--curmatchlength;//当前字符串已经插入
			while (curmatchlength) {
				start++;
				_ht.insert(matchhead, _pwin[start+2], start,hashaddr);
				--curmatchlength;
			}
			start++;
		}
		//检测先行缓冲区中剩余字符个数
		if ((lookahead <= MIN_LOOKHEAD)&&(!feof(fin))) {
			fillwindows(fin,lookahead);
		}
	}
	//标记位数不足8位
	if (bitcount > 0 && bitcount < 8) {
		chflag <<= (8 - bitcount);
		fputc(chflag,foutf);
	}
	//将数据文件+标记文件合并
	fflush(foutf);
	mergefile(fout, filesize);
	fclose(fin);
	fclose(fout);
	fclose(foutf);
}
void LZ77::uncompressfile(const std::string & strfilepath) {
	//打开压缩,标记文件指针
	FILE* fin1 = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin1) {
		std::cout << "open false" << std::endl;
		return;
	}
	FILE* fin2 = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin2) {
		std::cout << "open false" << std::endl;
		return;
	}
	//获取源文件大小
	ULL filesize = 0;
	fseek(fin2, 0 - sizeof(filesize), SEEK_END);
	fread(&filesize, sizeof(filesize), 1, fin2);
	//获取标记字节数
	size_t flagsize = 0;
	fseek(fin2, 0 - sizeof(flagsize) - sizeof(filesize), SEEK_END);
	fread(&flagsize, sizeof(flagsize), 1, fin2);
	//将标记指针移动到标记数据的起始位置
	fseek(fin2, 0 - sizeof(flagsize) - flagsize-sizeof(filesize), SEEK_END);
	//开始解压缩
	//写入解压缩数据
	FILE* fout = fopen("4.txt", "wb");
	assert(fout);
	FILE* f = fopen("4.txt", "rb");//读取匹配内容
	if (nullptr == f) {
		std::cout << "open false" << std::endl;
		return;
	}
	UCH bitcount = 0;
	UCH chflag = 0;
	UCH ch = 0;
	UCH matchlen = 0;
	USH matchdist = 0;
	ULL encodecount = 0;
	while (encodecount<filesize) {
		if (bitcount == 0) {
			chflag = fgetc(fin2);
			bitcount = 8;
		}
		if (chflag & 0x80) {
			//是len
			matchlen = fgetc(fin1) + 3;
			encodecount += matchlen;
			fflush(fout);//所以得清空缓冲区
			fread(&matchdist, sizeof(matchdist), 1, fin1);
			//定位文件指针
			fseek(f, 0-matchdist, SEEK_END);
			while (matchlen) {
				//ch为255，因为数据在缓冲区，还没写入
				ch = fgetc(f);
				fputc(ch, fout);
				matchlen--;
			}
		}
		else {
			//原字符
			ch = fgetc(fin1);
			fputc(ch, fout);
			encodecount++;
		}
		chflag <<= 1;
		bitcount--;
	}
	fclose(fin1);
	fclose(fin2);
	fclose(fout);
	fclose(f);
}
void LZ77::mergefile(FILE* fout,ULL filesize) {
	FILE* finf = fopen("3.txt", "rb");
	size_t flagsize = 0;
	UCH* preadbuff = new UCH[1024];
	while (true) {
		size_t rdsize = fread(preadbuff, 1, 1024, finf);
		if (0 == rdsize)
			break;
		fwrite(preadbuff, 1, rdsize, fout);
		flagsize += rdsize;
	}
	fwrite(&flagsize, sizeof(flagsize), 1, fout);
	fwrite(&filesize, sizeof(filesize), 1, fout);
	delete[] preadbuff;
	fclose(finf);
}
void LZ77::fillwindows(FILE* fin,size_t& lookahead){
	//将右窗口数据搬移到左窗口
	memcpy(_pwin, _pwin + WSIZE, WSIZE);

	//更新哈希表
	_ht.update();
	//head prev 中保存的下标
	//大于wsize -wsize
	//小于wsize 置为0
	//读取wsize个数据放置到右窗口
	if (!feof(fin)) {
		lookahead += fread(_pwin + WSIZE, 1, WSIZE, fin);
	}#include"LZ77.h"
#include<iostream>
#include<assert.h>
#include<stdlib.h>
#pragma warning(disable:4996)
LZ77::LZ77()
	:_pwin(new UCH[WSIZE*2])
	,_ht(WSIZE){}
LZ77::~LZ77() {
	delete[] _pwin;
	_pwin = nullptr;
}
void LZ77::compressfile(const std::string & strfilepath) {
	//如果源文件小于MIN_MATCH ，则不处理
	//获取文件大小
	FILE* fin = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin) {
		std::cout << "open false" << std::endl;
		return;
	}
	fseek(fin, 0, SEEK_END);
	ULL filesize = ftell(fin);//源文件的size
	if (filesize <= MIN_MATCH) {
		std::cout << "file small" << std::endl;
		return;
	}
	//从压缩文件读取一个缓冲区的数据
	fseek(fin, 0, SEEK_SET);
	size_t  lookahead = fread(_pwin, 1, 2 * WSIZE, fin);//实际读取多少
	USH start = 0;
	//与查找相关变量
	USH hashaddr = 0;
	USH matchhead = 0;
	USH curmatchlength = 0;
	USH curmatchdist = 0;
	//与写标记相关变量
	UCH chflag = 0;
	UCH bitcount = 0;
	bool islen = false;
	FILE *fout = fopen("2.lzp", "wb");
	assert(fout);
	FILE* foutf = fopen("3.txt", "wb");
	assert(foutf);
	//一个一个字符计算的
	//处理前两个字节
	for (USH i = 0; i < MIN_MATCH - 1; ++i) {
		_ht.hashfunc(hashaddr, _pwin[i]);
	}
	//
	//压缩
	while (lookahead) {
		curmatchdist = 0;
		curmatchlength = 0;
		//1.将当前字符串插入哈希表，并获取匹配头
		_ht.insert(matchhead, _pwin[start + 2],start,hashaddr);
		//2.验证在查找缓冲区中是否找到匹配
		if (matchhead != 0) {
			//找最长匹配,带出长度距离对
			curmatchlength = longestmatch(matchhead, curmatchdist,start);
		}
		if (curmatchlength < MIN_MATCH) {
			//没找到
			//将start位置字符写入压缩文件
			fputc(_pwin[start], fout);
			//写当前原字符对应的标记
			writeflage(foutf,chflag,bitcount,false);
			++start;
			lookahead--;
			
		}
		else {
			//找到了
			//将长度距离对写入压缩文件  
			//先写长度，在写距离。为了和Huffman结合
			UCH chlen = curmatchlength - 3;
			fputc(chlen, fout);//最少是3个，所以用0表示3
			fwrite(&curmatchdist, sizeof(curmatchdist), 1, fout);
			//写标记
			writeflage(foutf, chflag, bitcount, true);
			lookahead -= curmatchlength;//更新先行缓冲区中剩余字节数
			//将已经匹配的字符串按三个一组将其插入到哈希表中
			--curmatchlength;//当前字符串已经插入
			while (curmatchlength) {
				start++;
				_ht.insert(matchhead, _pwin[start+2], start,hashaddr);
				--curmatchlength;
			}
			start++;
		}
		//检测先行缓冲区中剩余字符个数
		if ((lookahead <= MIN_LOOKHEAD)&&(!feof(fin))) {
			fillwindows(fin,lookahead);
		}
	}
	//标记位数不足8位
	if (bitcount > 0 && bitcount < 8) {
		chflag <<= (8 - bitcount);
		fputc(chflag,foutf);
	}
	//将数据文件+标记文件合并
	fflush(foutf);
	mergefile(fout, filesize);
	fclose(fin);
	fclose(fout);
	fclose(foutf);
}
void LZ77::uncompressfile(const std::string & strfilepath) {
	//打开压缩,标记文件指针
	FILE* fin1 = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin1) {
		std::cout << "open false" << std::endl;
		return;
	}
	FILE* fin2 = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin2) {
		std::cout << "open false" << std::endl;
		return;
	}
	//获取源文件大小
	ULL filesize = 0;
	fseek(fin2, 0 - sizeof(filesize), SEEK_END);
	fread(&filesize, sizeof(filesize), 1, fin2);
	//获取标记字节数
	size_t flagsize = 0;
	fseek(fin2, 0 - sizeof(flagsize) - sizeof(filesize), SEEK_END);
	fread(&flagsize, sizeof(flagsize), 1, fin2);
	//将标记指针移动到标记数据的起始位置
	fseek(fin2, 0 - sizeof(flagsize) - flagsize-sizeof(filesize), SEEK_END);
	//开始解压缩
	//写入解压缩数据
	FILE* fout = fopen("4.txt", "wb");
	assert(fout);
	FILE* f = fopen("4.txt", "rb");//读取匹配内容
	if (nullptr == f) {
		std::cout << "open false" << std::endl;
		return;
	}
	UCH bitcount = 0;
	UCH chflag = 0;
	UCH ch = 0;
	UCH matchlen = 0;
	USH matchdist = 0;
	ULL encodecount = 0;
	while (encodecount<filesize) {
		if (bitcount == 0) {
			chflag = fgetc(fin2);
			bitcount = 8;
		}
		if (chflag & 0x80) {
			//是len
			matchlen = fgetc(fin1) + 3;
			encodecount += matchlen;
			fflush(fout);//所以得清空缓冲区
			fread(&matchdist, sizeof(matchdist), 1, fin1);
			//定位文件指针
			fseek(f, 0-matchdist, SEEK_END);
			while (matchlen) {
				//ch为255，因为数据在缓冲区，还没写入
				ch = fgetc(f);
				fputc(ch, fout);
				matchlen--;
			}
		}
		else {
			//原字符
			ch = fgetc(fin1);
			fputc(ch, fout);
			encodecount++;
		}
		chflag <<= 1;
		bitcount--;
	}
	fclose(fin1);
	fclose(fin2);
	fclose(fout);
	fclose(f);
}
void LZ77::mergefile(FILE* fout,ULL filesize) {
	FILE* finf = fopen("3.txt", "rb");
	size_t flagsize = 0;
	UCH* preadbuff = new UCH[1024];
	while (true) {
		size_t rdsize = fread(preadbuff, 1, 1024, finf);
		if (0 == rdsize)
			break;
		fwrite(preadbuff, 1, rdsize, fout);
		flagsize += rdsize;
	}
	fwrite(&flagsize, sizeof(flagsize), 1, fout);
	fwrite(&filesize, sizeof(filesize), 1, fout);
	delete[] preadbuff;
	fclose(finf);
}
void LZ77::fillwindows(FILE* fin,size_t& lookahead){
	//将右窗口数据搬移到左窗口
	memcpy(_pwin, _pwin + WSIZE, WSIZE);

	//更新哈希表
	_ht.update();
	//head prev 中保存的下标
	//大于wsize -wsize
	//小于wsize 置为0
	//读取wsize个数据放置到右窗口
	if (!feof(fin)) {
		lookahead += fread(_pwin + WSIZE, 1, WSIZE, fin);
	}
}
#include"LZ77.h"
#include<iostream>
#include<assert.h>
#include<stdlib.h>
#pragma warning(disable:4996)
LZ77::LZ77()
	:_pwin(new UCH[WSIZE*2])
	,_ht(WSIZE){}
LZ77::~LZ77() {
	delete[] _pwin;
	_pwin = nullptr;
}
void LZ77::compressfile(const std::string & strfilepath) {
	//如果源文件小于MIN_MATCH ，则不处理
	//获取文件大小
	FILE* fin = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin) {
		std::cout << "open false" << std::endl;
		return;
	}
	fseek(fin, 0, SEEK_END);
	ULL filesize = ftell(fin);//源文件的size
	if (filesize <= MIN_MATCH) {
		std::cout << "file small" << std::endl;
		return;
	}
	//从压缩文件读取一个缓冲区的数据
	fseek(fin, 0, SEEK_SET);
	size_t  lookahead = fread(_pwin, 1, 2 * WSIZE, fin);//实际读取多少
	USH start = 0;
	//与查找相关变量
	USH hashaddr = 0;
	USH matchhead = 0;
	USH curmatchlength = 0;
	USH curmatchdist = 0;
	//与写标记相关变量
	UCH chflag = 0;
	UCH bitcount = 0;
	bool islen = false;
	FILE *fout = fopen("2.lzp", "wb");
	assert(fout);
	FILE* foutf = fopen("3.txt", "wb");
	assert(foutf);
	//一个一个字符计算的
	//处理前两个字节
	for (USH i = 0; i < MIN_MATCH - 1; ++i) {
		_ht.hashfunc(hashaddr, _pwin[i]);
	}
	//
	//压缩
	while (lookahead) {
		curmatchdist = 0;
		curmatchlength = 0;
		//1.将当前字符串插入哈希表，并获取匹配头
		_ht.insert(matchhead, _pwin[start + 2],start,hashaddr);
		//2.验证在查找缓冲区中是否找到匹配
		if (matchhead != 0) {
			//找最长匹配,带出长度距离对
			curmatchlength = longestmatch(matchhead, curmatchdist,start);
		}
		if (curmatchlength < MIN_MATCH) {
			//没找到
			//将start位置字符写入压缩文件
			fputc(_pwin[start], fout);
			//写当前原字符对应的标记
			writeflage(foutf,chflag,bitcount,false);
			++start;
			lookahead--;
			
		}
		else {
			//找到了
			//将长度距离对写入压缩文件  
			//先写长度，在写距离。为了和Huffman结合
			UCH chlen = curmatchlength - 3;
			fputc(chlen, fout);//最少是3个，所以用0表示3
			fwrite(&curmatchdist, sizeof(curmatchdist), 1, fout);
			//写标记
			writeflage(foutf, chflag, bitcount, true);
			lookahead -= curmatchlength;//更新先行缓冲区中剩余字节数
			//将已经匹配的字符串按三个一组将其插入到哈希表中
			--curmatchlength;//当前字符串已经插入
			while (curmatchlength) {
				start++;
				_ht.insert(matchhead, _pwin[start+2], start,hashaddr);
				--curmatchlength;
			}
			start++;
		}
		//检测先行缓冲区中剩余字符个数
		if ((lookahead <= MIN_LOOKHEAD)&&(!feof(fin))) {
			fillwindows(fin,lookahead);
		}
	}
	//标记位数不足8位
	if (bitcount > 0 && bitcount < 8) {
		chflag <<= (8 - bitcount);
		fputc(chflag,foutf);
	}
	//将数据文件+标记文件合并
	fflush(foutf);
	mergefile(fout, filesize);
	fclose(fin);
	fclose(fout);
	fclose(foutf);
}
void LZ77::uncompressfile(const std::string & strfilepath) {
	//打开压缩,标记文件指针
	FILE* fin1 = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin1) {
		std::cout << "open false" << std::endl;
		return;
	}
	FILE* fin2 = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin2) {
		std::cout << "open false" << std::endl;
		return;
	}
	//获取源文件大小
	ULL filesize = 0;
	fseek(fin2, 0 - sizeof(filesize), SEEK_END);
	fread(&filesize, sizeof(filesize), 1, fin2);
	//获取标记字节数
	size_t flagsize = 0;
	fseek(fin2, 0 - sizeof(flagsize) - sizeof(filesize), SEEK_END);
	fread(&flagsize, sizeof(flagsize), 1, fin2);
	//将标记指针移动到标记数据的起始位置
	fseek(fin2, 0 - sizeof(flagsize) - flagsize-sizeof(filesize), SEEK_END);
	//开始解压缩
	//写入解压缩数据
	FILE* fout = fopen("4.txt", "wb");
	assert(fout);
	FILE* f = fopen("4.txt", "rb");//读取匹配内容
	if (nullptr == f) {
		std::cout << "open false" << std::endl;
		return;
	}
	UCH bitcount = 0;
	UCH chflag = 0;
	UCH ch = 0;
	UCH matchlen = 0;
	USH matchdist = 0;
	ULL encodecount = 0;
	while (encodecount<filesize) {
		if (bitcount == 0) {
			chflag = fgetc(fin2);
			bitcount = 8;
		}
		if (chflag & 0x80) {
			//是len
			matchlen = fgetc(fin1) + 3;
			encodecount += matchlen;
			fflush(fout);//所以得清空缓冲区
			fread(&matchdist, sizeof(matchdist), 1, fin1);
			//定位文件指针
			fseek(f, 0-matchdist, SEEK_END);
			while (matchlen) {
				//ch为255，因为数据在缓冲区，还没写入
				ch = fgetc(f);
				fputc(ch, fout);
				matchlen--;
			}
		}
		else {
			//原字符
			ch = fgetc(fin1);
			fputc(ch, fout);
			encodecount++;
		}
		chflag <<= 1;
		bitcount--;
	}
	fclose(fin1);
	fclose(fin2);
	fclose(fout);
	fclose(f);
}
void LZ77::mergefile(FILE* fout,ULL filesize) {
	FILE* finf = fopen("3.txt", "rb");
	size_t flagsize = 0;
	UCH* preadbuff = new UCH[1024];
	while (true) {
		size_t rdsize = fread(preadbuff, 1, 1024, finf);
		if (0 == rdsize)
			break;
		fwrite(preadbuff, 1, rdsize, fout);
		flagsize += rdsize;
	}
	fwrite(&flagsize, sizeof(flagsize), 1, fout);
	fwrite(&filesize, sizeof(filesize), 1, fout);
	delete[] preadbuff;
	fclose(finf);
}
void LZ77::fillwindows(FILE* fin,size_t& lookahead){
	//将右窗口数据搬移到左窗口
	memcpy(_pwin, _pwin + WSIZE, WSIZE);

	//更新哈希表
	_ht.update();
	//head prev 中保存的下标
	//大于wsize -wsize
	//小于wsize 置为0
	//读取wsize个数据放置到右窗口
	if (!feof(fin)) {
		lookahead += fread(_pwin + WSIZE, 1, WSIZE, fin);
	}#include"LZ77.h"
#include<iostream>
#include<assert.h>
#include<stdlib.h>
#pragma warning(disable:4996)
LZ77::LZ77()
	:_pwin(new UCH[WSIZE*2])
	,_ht(WSIZE){}
LZ77::~LZ77() {
	delete[] _pwin;
	_pwin = nullptr;
}
void LZ77::compressfile(const std::string & strfilepath) {
	//如果源文件小于MIN_MATCH ，则不处理
	//获取文件大小
	FILE* fin = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin) {
		std::cout << "open false" << std::endl;
		return;
	}
	fseek(fin, 0, SEEK_END);
	ULL filesize = ftell(fin);//源文件的size
	if (filesize <= MIN_MATCH) {
		std::cout << "file small" << std::endl;
		return;
	}
	//从压缩文件读取一个缓冲区的数据
	fseek(fin, 0, SEEK_SET);
	size_t  lookahead = fread(_pwin, 1, 2 * WSIZE, fin);//实际读取多少
	USH start = 0;
	//与查找相关变量
	USH hashaddr = 0;
	USH matchhead = 0;
	USH curmatchlength = 0;
	USH curmatchdist = 0;
	//与写标记相关变量
	UCH chflag = 0;
	UCH bitcount = 0;
	bool islen = false;
	FILE *fout = fopen("2.lzp", "wb");
	assert(fout);
	FILE* foutf = fopen("3.txt", "wb");
	assert(foutf);
	//一个一个字符计算的
	//处理前两个字节
	for (USH i = 0; i < MIN_MATCH - 1; ++i) {
		_ht.hashfunc(hashaddr, _pwin[i]);
	}
	//
	//压缩
	while (lookahead) {
		curmatchdist = 0;
		curmatchlength = 0;
		//1.将当前字符串插入哈希表，并获取匹配头
		_ht.insert(matchhead, _pwin[start + 2],start,hashaddr);
		//2.验证在查找缓冲区中是否找到匹配
		if (matchhead != 0) {
			//找最长匹配,带出长度距离对
			curmatchlength = longestmatch(matchhead, curmatchdist,start);
		}
		if (curmatchlength < MIN_MATCH) {
			//没找到
			//将start位置字符写入压缩文件
			fputc(_pwin[start], fout);
			//写当前原字符对应的标记
			writeflage(foutf,chflag,bitcount,false);
			++start;
			lookahead--;
			
		}
		else {
			//找到了
			//将长度距离对写入压缩文件  
			//先写长度，在写距离。为了和Huffman结合
			UCH chlen = curmatchlength - 3;
			fputc(chlen, fout);//最少是3个，所以用0表示3
			fwrite(&curmatchdist, sizeof(curmatchdist), 1, fout);
			//写标记
			writeflage(foutf, chflag, bitcount, true);
			lookahead -= curmatchlength;//更新先行缓冲区中剩余字节数
			//将已经匹配的字符串按三个一组将其插入到哈希表中
			--curmatchlength;//当前字符串已经插入
			while (curmatchlength) {
				start++;
				_ht.insert(matchhead, _pwin[start+2], start,hashaddr);
				--curmatchlength;
			}
			start++;
		}
		//检测先行缓冲区中剩余字符个数
		if ((lookahead <= MIN_LOOKHEAD)&&(!feof(fin))) {
			fillwindows(fin,lookahead);
		}
	}
	//标记位数不足8位
	if (bitcount > 0 && bitcount < 8) {
		chflag <<= (8 - bitcount);
		fputc(chflag,foutf);
	}
	//将数据文件+标记文件合并
	fflush(foutf);
	mergefile(fout, filesize);
	fclose(fin);
	fclose(fout);
	fclose(foutf);
}
void LZ77::uncompressfile(const std::string & strfilepath) {
	//打开压缩,标记文件指针
	FILE* fin1 = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin1) {
		std::cout << "open false" << std::endl;
		return;
	}
	FILE* fin2 = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin2) {
		std::cout << "open false" << std::endl;
		return;
	}
	//获取源文件大小
	ULL filesize = 0;
	fseek(fin2, 0 - sizeof(filesize), SEEK_END);
	fread(&filesize, sizeof(filesize), 1, fin2);
	//获取标记字节数
	size_t flagsize = 0;
	fseek(fin2, 0 - sizeof(flagsize) - sizeof(filesize), SEEK_END);
	fread(&flagsize, sizeof(flagsize), 1, fin2);
	//将标记指针移动到标记数据的起始位置
	fseek(fin2, 0 - sizeof(flagsize) - flagsize-sizeof(filesize), SEEK_END);
	//开始解压缩
	//写入解压缩数据
	FILE* fout = fopen("4.txt", "wb");
	assert(fout);
	FILE* f = fopen("4.txt", "rb");//读取匹配内容
	if (nullptr == f) {
		std::cout << "open false" << std::endl;
		return;
	}
	UCH bitcount = 0;
	UCH chflag = 0;
	UCH ch = 0;
	UCH matchlen = 0;
	USH matchdist = 0;
	ULL encodecount = 0;
	while (encodecount<filesize) {
		if (bitcount == 0) {
			chflag = fgetc(fin2);
			bitcount = 8;
		}
		if (chflag & 0x80) {
			//是len
			matchlen = fgetc(fin1) + 3;
			encodecount += matchlen;
			fflush(fout);//所以得清空缓冲区
			fread(&matchdist, sizeof(matchdist), 1, fin1);
			//定位文件指针
			fseek(f, 0-matchdist, SEEK_END);
			while (matchlen) {
				//ch为255，因为数据在缓冲区，还没写入
				ch = fgetc(f);
				fputc(ch, fout);
				matchlen--;
			}
		}
		else {
			//原字符
			ch = fgetc(fin1);
			fputc(ch, fout);
			encodecount++;
		}
		chflag <<= 1;
		bitcount--;
	}
	fclose(fin1);
	fclose(fin2);
	fclose(fout);
	fclose(f);
}
void LZ77::mergefile(FILE* fout,ULL filesize) {
	FILE* finf = fopen("3.txt", "rb");
	size_t flagsize = 0;
	UCH* preadbuff = new UCH[1024];
	while (true) {
		size_t rdsize = fread(preadbuff, 1, 1024, finf);
		if (0 == rdsize)
			break;
		fwrite(preadbuff, 1, rdsize, fout);
		flagsize += rdsize;
	}
	fwrite(&flagsize, sizeof(flagsize), 1, fout);
	fwrite(&filesize, sizeof(filesize), 1, fout);
	delete[] preadbuff;
	fclose(finf);
}
void LZ77::fillwindows(FILE* fin,size_t& lookahead){
	//将右窗口数据搬移到左窗口
	memcpy(_pwin, _pwin + WSIZE, WSIZE);

	//更新哈希表
	_ht.update();
	//head prev 中保存的下标
	//大于wsize -wsize
	//小于wsize 置为0
	//读取wsize个数据放置到右窗口
	if (!feof(fin)) {
		lookahead += fread(_pwin + WSIZE, 1, WSIZE, fin);
	}
}
#include"LZ77.h"
#include<iostream>
#include<assert.h>
#include<stdlib.h>
#pragma warning(disable:4996)
LZ77::LZ77()
	:_pwin(new UCH[WSIZE*2])
	,_ht(WSIZE){}
LZ77::~LZ77() {
	delete[] _pwin;
	_pwin = nullptr;
}
void LZ77::compressfile(const std::string & strfilepath) {
	//如果源文件小于MIN_MATCH ，则不处理
	//获取文件大小
	FILE* fin = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin) {
		std::cout << "open false" << std::endl;
		return;
	}
	fseek(fin, 0, SEEK_END);
	ULL filesize = ftell(fin);//源文件的size
	if (filesize <= MIN_MATCH) {
		std::cout << "file small" << std::endl;
		return;
	}
	//从压缩文件读取一个缓冲区的数据
	fseek(fin, 0, SEEK_SET);
	size_t  lookahead = fread(_pwin, 1, 2 * WSIZE, fin);//实际读取多少
	USH start = 0;
	//与查找相关变量
	USH hashaddr = 0;
	USH matchhead = 0;
	USH curmatchlength = 0;
	USH curmatchdist = 0;
	//与写标记相关变量
	UCH chflag = 0;
	UCH bitcount = 0;
	bool islen = false;
	FILE *fout = fopen("2.lzp", "wb");
	assert(fout);
	FILE* foutf = fopen("3.txt", "wb");
	assert(foutf);
	//一个一个字符计算的
	//处理前两个字节
	for (USH i = 0; i < MIN_MATCH - 1; ++i) {
		_ht.hashfunc(hashaddr, _pwin[i]);
	}
	//
	//压缩
	while (lookahead) {
		curmatchdist = 0;
		curmatchlength = 0;
		//1.将当前字符串插入哈希表，并获取匹配头
		_ht.insert(matchhead, _pwin[start + 2],start,hashaddr);
		//2.验证在查找缓冲区中是否找到匹配
		if (matchhead != 0) {
			//找最长匹配,带出长度距离对
			curmatchlength = longestmatch(matchhead, curmatchdist,start);
		}
		if (curmatchlength < MIN_MATCH) {
			//没找到
			//将start位置字符写入压缩文件
			fputc(_pwin[start], fout);
			//写当前原字符对应的标记
			writeflage(foutf,chflag,bitcount,false);
			++start;
			lookahead--;
			
		}
		else {
			//找到了
			//将长度距离对写入压缩文件  
			//先写长度，在写距离。为了和Huffman结合
			UCH chlen = curmatchlength - 3;
			fputc(chlen, fout);//最少是3个，所以用0表示3
			fwrite(&curmatchdist, sizeof(curmatchdist), 1, fout);
			//写标记
			writeflage(foutf, chflag, bitcount, true);
			lookahead -= curmatchlength;//更新先行缓冲区中剩余字节数
			//将已经匹配的字符串按三个一组将其插入到哈希表中
			--curmatchlength;//当前字符串已经插入
			while (curmatchlength) {
				start++;
				_ht.insert(matchhead, _pwin[start+2], start,hashaddr);
				--curmatchlength;
			}
			start++;
		}
		//检测先行缓冲区中剩余字符个数
		if ((lookahead <= MIN_LOOKHEAD)&&(!feof(fin))) {
			fillwindows(fin,lookahead);
		}
	}
	//标记位数不足8位
	if (bitcount > 0 && bitcount < 8) {
		chflag <<= (8 - bitcount);
		fputc(chflag,foutf);
	}
	//将数据文件+标记文件合并
	fflush(foutf);
	mergefile(fout, filesize);
	fclose(fin);
	fclose(fout);
	fclose(foutf);
}
void LZ77::uncompressfile(const std::string & strfilepath) {
	//打开压缩,标记文件指针
	FILE* fin1 = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin1) {
		std::cout << "open false" << std::endl;
		return;
	}
	FILE* fin2 = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin2) {
		std::cout << "open false" << std::endl;
		return;
	}
	//获取源文件大小
	ULL filesize = 0;
	fseek(fin2, 0 - sizeof(filesize), SEEK_END);
	fread(&filesize, sizeof(filesize), 1, fin2);
	//获取标记字节数
	size_t flagsize = 0;
	fseek(fin2, 0 - sizeof(flagsize) - sizeof(filesize), SEEK_END);
	fread(&flagsize, sizeof(flagsize), 1, fin2);
	//将标记指针移动到标记数据的起始位置
	fseek(fin2, 0 - sizeof(flagsize) - flagsize-sizeof(filesize), SEEK_END);
	//开始解压缩
	//写入解压缩数据
	FILE* fout = fopen("4.txt", "wb");
	assert(fout);
	FILE* f = fopen("4.txt", "rb");//读取匹配内容
	if (nullptr == f) {
		std::cout << "open false" << std::endl;
		return;
	}
	UCH bitcount = 0;
	UCH chflag = 0;
	UCH ch = 0;
	UCH matchlen = 0;
	USH matchdist = 0;
	ULL encodecount = 0;
	while (encodecount<filesize) {
		if (bitcount == 0) {
			chflag = fgetc(fin2);
			bitcount = 8;
		}
		if (chflag & 0x80) {
			//是len
			matchlen = fgetc(fin1) + 3;
			encodecount += matchlen;
			fflush(fout);//所以得清空缓冲区
			fread(&matchdist, sizeof(matchdist), 1, fin1);
			//定位文件指针
			fseek(f, 0-matchdist, SEEK_END);
			while (matchlen) {
				//ch为255，因为数据在缓冲区，还没写入
				ch = fgetc(f);
				fputc(ch, fout);
				matchlen--;
			}
		}
		else {
			//原字符
			ch = fgetc(fin1);
			fputc(ch, fout);
			encodecount++;
		}
		chflag <<= 1;
		bitcount--;
	}
	fclose(fin1);
	fclose(fin2);
	fclose(fout);
	fclose(f);
}
void LZ77::mergefile(FILE* fout,ULL filesize) {
	FILE* finf = fopen("3.txt", "rb");
	size_t flagsize = 0;
	UCH* preadbuff = new UCH[1024];
	while (true) {
		size_t rdsize = fread(preadbuff, 1, 1024, finf);
		if (0 == rdsize)
			break;
		fwrite(preadbuff, 1, rdsize, fout);
		flagsize += rdsize;
	}
	fwrite(&flagsize, sizeof(flagsize), 1, fout);
	fwrite(&filesize, sizeof(filesize), 1, fout);
	delete[] preadbuff;
	fclose(finf);
}
void LZ77::fillwindows(FILE* fin,size_t& lookahead){
	//将右窗口数据搬移到左窗口
	memcpy(_pwin, _pwin + WSIZE, WSIZE);

	//更新哈希表
	_ht.update();
	//head prev 中保存的下标
	//大于wsize -wsize
	//小于wsize 置为0
	//读取wsize个数据放置到右窗口
	if (!feof(fin)) {
		lookahead += fread(_pwin + WSIZE, 1, WSIZE, fin);
	}#include"LZ77.h"
#include<iostream>
#include<assert.h>
#include<stdlib.h>
#pragma warning(disable:4996)
LZ77::LZ77()
	:_pwin(new UCH[WSIZE*2])
	,_ht(WSIZE){}
LZ77::~LZ77() {
	delete[] _pwin;
	_pwin = nullptr;
}
void LZ77::compressfile(const std::string & strfilepath) {
	//如果源文件小于MIN_MATCH ，则不处理
	//获取文件大小
	FILE* fin = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin) {
		std::cout << "open false" << std::endl;
		return;
	}
	fseek(fin, 0, SEEK_END);
	ULL filesize = ftell(fin);//源文件的size
	if (filesize <= MIN_MATCH) {
		std::cout << "file small" << std::endl;
		return;
	}
	//从压缩文件读取一个缓冲区的数据
	fseek(fin, 0, SEEK_SET);
	size_t  lookahead = fread(_pwin, 1, 2 * WSIZE, fin);//实际读取多少
	USH start = 0;
	//与查找相关变量
	USH hashaddr = 0;
	USH matchhead = 0;
	USH curmatchlength = 0;
	USH curmatchdist = 0;
	//与写标记相关变量
	UCH chflag = 0;
	UCH bitcount = 0;
	bool islen = false;
	FILE *fout = fopen("2.lzp", "wb");
	assert(fout);
	FILE* foutf = fopen("3.txt", "wb");
	assert(foutf);
	//一个一个字符计算的
	//处理前两个字节
	for (USH i = 0; i < MIN_MATCH - 1; ++i) {
		_ht.hashfunc(hashaddr, _pwin[i]);
	}
	//
	//压缩
	while (lookahead) {
		curmatchdist = 0;
		curmatchlength = 0;
		//1.将当前字符串插入哈希表，并获取匹配头
		_ht.insert(matchhead, _pwin[start + 2],start,hashaddr);
		//2.验证在查找缓冲区中是否找到匹配
		if (matchhead != 0) {
			//找最长匹配,带出长度距离对
			curmatchlength = longestmatch(matchhead, curmatchdist,start);
		}
		if (curmatchlength < MIN_MATCH) {
			//没找到
			//将start位置字符写入压缩文件
			fputc(_pwin[start], fout);
			//写当前原字符对应的标记
			writeflage(foutf,chflag,bitcount,false);
			++start;
			lookahead--;
			
		}
		else {
			//找到了
			//将长度距离对写入压缩文件  
			//先写长度，在写距离。为了和Huffman结合
			UCH chlen = curmatchlength - 3;
			fputc(chlen, fout);//最少是3个，所以用0表示3
			fwrite(&curmatchdist, sizeof(curmatchdist), 1, fout);
			//写标记
			writeflage(foutf, chflag, bitcount, true);
			lookahead -= curmatchlength;//更新先行缓冲区中剩余字节数
			//将已经匹配的字符串按三个一组将其插入到哈希表中
			--curmatchlength;//当前字符串已经插入
			while (curmatchlength) {
				start++;
				_ht.insert(matchhead, _pwin[start+2], start,hashaddr);
				--curmatchlength;
			}
			start++;
		}
		//检测先行缓冲区中剩余字符个数
		if ((lookahead <= MIN_LOOKHEAD)&&(!feof(fin))) {
			fillwindows(fin,lookahead);
		}
	}
	//标记位数不足8位
	if (bitcount > 0 && bitcount < 8) {
		chflag <<= (8 - bitcount);
		fputc(chflag,foutf);
	}
	//将数据文件+标记文件合并
	fflush(foutf);
	mergefile(fout, filesize);
	fclose(fin);
	fclose(fout);
	fclose(foutf);
}
void LZ77::uncompressfile(const std::string & strfilepath) {
	//打开压缩,标记文件指针
	FILE* fin1 = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin1) {
		std::cout << "open false" << std::endl;
		return;
	}
	FILE* fin2 = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin2) {
		std::cout << "open false" << std::endl;
		return;
	}
	//获取源文件大小
	ULL filesize = 0;
	fseek(fin2, 0 - sizeof(filesize), SEEK_END);
	fread(&filesize, sizeof(filesize), 1, fin2);
	//获取标记字节数
	size_t flagsize = 0;
	fseek(fin2, 0 - sizeof(flagsize) - sizeof(filesize), SEEK_END);
	fread(&flagsize, sizeof(flagsize), 1, fin2);
	//将标记指针移动到标记数据的起始位置
	fseek(fin2, 0 - sizeof(flagsize) - flagsize-sizeof(filesize), SEEK_END);
	//开始解压缩
	//写入解压缩数据
	FILE* fout = fopen("4.txt", "wb");
	assert(fout);
	FILE* f = fopen("4.txt", "rb");//读取匹配内容
	if (nullptr == f) {
		std::cout << "open false" << std::endl;
		return;
	}
	UCH bitcount = 0;
	UCH chflag = 0;
	UCH ch = 0;
	UCH matchlen = 0;
	USH matchdist = 0;
	ULL encodecount = 0;
	while (encodecount<filesize) {
		if (bitcount == 0) {
			chflag = fgetc(fin2);
			bitcount = 8;
		}
		if (chflag & 0x80) {
			//是len
			matchlen = fgetc(fin1) + 3;
			encodecount += matchlen;
			fflush(fout);//所以得清空缓冲区
			fread(&matchdist, sizeof(matchdist), 1, fin1);
			//定位文件指针
			fseek(f, 0-matchdist, SEEK_END);
			while (matchlen) {
				//ch为255，因为数据在缓冲区，还没写入
				ch = fgetc(f);
				fputc(ch, fout);
				matchlen--;
			}
		}
		else {
			//原字符
			ch = fgetc(fin1);
			fputc(ch, fout);
			encodecount++;
		}
		chflag <<= 1;
		bitcount--;
	}
	fclose(fin1);
	fclose(fin2);
	fclose(fout);
	fclose(f);
}
void LZ77::mergefile(FILE* fout,ULL filesize) {
	FILE* finf = fopen("3.txt", "rb");
	size_t flagsize = 0;
	UCH* preadbuff = new UCH[1024];
	while (true) {
		size_t rdsize = fread(preadbuff, 1, 1024, finf);
		if (0 == rdsize)
			break;
		fwrite(preadbuff, 1, rdsize, fout);
		flagsize += rdsize;
	}
	fwrite(&flagsize, sizeof(flagsize), 1, fout);
	fwrite(&filesize, sizeof(filesize), 1, fout);
	delete[] preadbuff;
	fclose(finf);
}
void LZ77::fillwindows(FILE* fin,size_t& lookahead){
	//将右窗口数据搬移到左窗口
	memcpy(_pwin, _pwin + WSIZE, WSIZE);

	//更新哈希表
	_ht.update();
	//head prev 中保存的下标
	//大于wsize -wsize
	//小于wsize 置为0
	//读取wsize个数据放置到右窗口
	if (!feof(fin)) {
		lookahead += fread(_pwin + WSIZE, 1, WSIZE, fin);
	}
}
#include"LZ77.h"
#include<iostream>
#include<assert.h>
#include<stdlib.h>
#pragma warning(disable:4996)
LZ77::LZ77()
	:_pwin(new UCH[WSIZE*2])
	,_ht(WSIZE){}
LZ77::~LZ77() {
	delete[] _pwin;
	_pwin = nullptr;
}
void LZ77::compressfile(const std::string & strfilepath) {
	//如果源文件小于MIN_MATCH ，则不处理
	//获取文件大小
	FILE* fin = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin) {
		std::cout << "open false" << std::endl;
		return;
	}
	fseek(fin, 0, SEEK_END);
	ULL filesize = ftell(fin);//源文件的size
	if (filesize <= MIN_MATCH) {
		std::cout << "file small" << std::endl;
		return;
	}
	//从压缩文件读取一个缓冲区的数据
	fseek(fin, 0, SEEK_SET);
	size_t  lookahead = fread(_pwin, 1, 2 * WSIZE, fin);//实际读取多少
	USH start = 0;
	//与查找相关变量
	USH hashaddr = 0;
	USH matchhead = 0;
	USH curmatchlength = 0;
	USH curmatchdist = 0;
	//与写标记相关变量
	UCH chflag = 0;
	UCH bitcount = 0;
	bool islen = false;
	FILE *fout = fopen("2.lzp", "wb");
	assert(fout);
	FILE* foutf = fopen("3.txt", "wb");
	assert(foutf);
	//一个一个字符计算的
	//处理前两个字节
	for (USH i = 0; i < MIN_MATCH - 1; ++i) {
		_ht.hashfunc(hashaddr, _pwin[i]);
	}
	//
	//压缩
	while (lookahead) {
		curmatchdist = 0;
		curmatchlength = 0;
		//1.将当前字符串插入哈希表，并获取匹配头
		_ht.insert(matchhead, _pwin[start + 2],start,hashaddr);
		//2.验证在查找缓冲区中是否找到匹配
		if (matchhead != 0) {
			//找最长匹配,带出长度距离对
			curmatchlength = longestmatch(matchhead, curmatchdist,start);
		}
		if (curmatchlength < MIN_MATCH) {
			//没找到
			//将start位置字符写入压缩文件
			fputc(_pwin[start], fout);
			//写当前原字符对应的标记
			writeflage(foutf,chflag,bitcount,false);
			++start;
			lookahead--;
			
		}
		else {
			//找到了
			//将长度距离对写入压缩文件  
			//先写长度，在写距离。为了和Huffman结合
			UCH chlen = curmatchlength - 3;
			fputc(chlen, fout);//最少是3个，所以用0表示3
			fwrite(&curmatchdist, sizeof(curmatchdist), 1, fout);
			//写标记
			writeflage(foutf, chflag, bitcount, true);
			lookahead -= curmatchlength;//更新先行缓冲区中剩余字节数
			//将已经匹配的字符串按三个一组将其插入到哈希表中
			--curmatchlength;//当前字符串已经插入
			while (curmatchlength) {
				start++;
				_ht.insert(matchhead, _pwin[start+2], start,hashaddr);
				--curmatchlength;
			}
			start++;
		}
		//检测先行缓冲区中剩余字符个数
		if ((lookahead <= MIN_LOOKHEAD)&&(!feof(fin))) {
			fillwindows(fin,lookahead);
		}
	}
	//标记位数不足8位
	if (bitcount > 0 && bitcount < 8) {
		chflag <<= (8 - bitcount);
		fputc(chflag,foutf);
	}
	//将数据文件+标记文件合并
	fflush(foutf);
	mergefile(fout, filesize);
	fclose(fin);
	fclose(fout);
	fclose(foutf);
}
void LZ77::uncompressfile(const std::string & strfilepath) {
	//打开压缩,标记文件指针
	FILE* fin1 = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin1) {
		std::cout << "open false" << std::endl;
		return;
	}
	FILE* fin2 = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin2) {
		std::cout << "open false" << std::endl;
		return;
	}
	//获取源文件大小
	ULL filesize = 0;
	fseek(fin2, 0 - sizeof(filesize), SEEK_END);
	fread(&filesize, sizeof(filesize), 1, fin2);
	//获取标记字节数
	size_t flagsize = 0;
	fseek(fin2, 0 - sizeof(flagsize) - sizeof(filesize), SEEK_END);
	fread(&flagsize, sizeof(flagsize), 1, fin2);
	//将标记指针移动到标记数据的起始位置
	fseek(fin2, 0 - sizeof(flagsize) - flagsize-sizeof(filesize), SEEK_END);
	//开始解压缩
	//写入解压缩数据
	FILE* fout = fopen("4.txt", "wb");
	assert(fout);
	FILE* f = fopen("4.txt", "rb");//读取匹配内容
	if (nullptr == f) {
		std::cout << "open false" << std::endl;
		return;
	}
	UCH bitcount = 0;
	UCH chflag = 0;
	UCH ch = 0;
	UCH matchlen = 0;
	USH matchdist = 0;
	ULL encodecount = 0;
	while (encodecount<filesize) {
		if (bitcount == 0) {
			chflag = fgetc(fin2);
			bitcount = 8;
		}
		if (chflag & 0x80) {
			//是len
			matchlen = fgetc(fin1) + 3;
			encodecount += matchlen;
			fflush(fout);//所以得清空缓冲区
			fread(&matchdist, sizeof(matchdist), 1, fin1);
			//定位文件指针
			fseek(f, 0-matchdist, SEEK_END);
			while (matchlen) {
				//ch为255，因为数据在缓冲区，还没写入
				ch = fgetc(f);
				fputc(ch, fout);
				matchlen--;
			}
		}
		else {
			//原字符
			ch = fgetc(fin1);
			fputc(ch, fout);
			encodecount++;
		}
		chflag <<= 1;
		bitcount--;
	}
	fclose(fin1);
	fclose(fin2);
	fclose(fout);
	fclose(f);
}
void LZ77::mergefile(FILE* fout,ULL filesize) {
	FILE* finf = fopen("3.txt", "rb");
	size_t flagsize = 0;
	UCH* preadbuff = new UCH[1024];
	while (true) {
		size_t rdsize = fread(preadbuff, 1, 1024, finf);
		if (0 == rdsize)
			break;
		fwrite(preadbuff, 1, rdsize, fout);
		flagsize += rdsize;
	}
	fwrite(&flagsize, sizeof(flagsize), 1, fout);
	fwrite(&filesize, sizeof(filesize), 1, fout);
	delete[] preadbuff;
	fclose(finf);
}
void LZ77::fillwindows(FILE* fin,size_t& lookahead){
	//将右窗口数据搬移到左窗口
	memcpy(_pwin, _pwin + WSIZE, WSIZE);

	//更新哈希表
	_ht.update();
	//head prev 中保存的下标
	//大于wsize -wsize
	//小于wsize 置为0
	//读取wsize个数据放置到右窗口
	if (!feof(fin)) {
		lookahead += fread(_pwin + WSIZE, 1, WSIZE, fin);
	}#include"LZ77.h"
#include<iostream>
#include<assert.h>
#include<stdlib.h>
#pragma warning(disable:4996)
LZ77::LZ77()
	:_pwin(new UCH[WSIZE*2])
	,_ht(WSIZE){}
LZ77::~LZ77() {
	delete[] _pwin;
	_pwin = nullptr;
}
void LZ77::compressfile(const std::string & strfilepath) {
	//如果源文件小于MIN_MATCH ，则不处理
	//获取文件大小
	FILE* fin = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin) {
		std::cout << "open false" << std::endl;
		return;
	}
	fseek(fin, 0, SEEK_END);
	ULL filesize = ftell(fin);//源文件的size
	if (filesize <= MIN_MATCH) {
		std::cout << "file small" << std::endl;
		return;
	}
	//从压缩文件读取一个缓冲区的数据
	fseek(fin, 0, SEEK_SET);
	size_t  lookahead = fread(_pwin, 1, 2 * WSIZE, fin);//实际读取多少
	USH start = 0;
	//与查找相关变量
	USH hashaddr = 0;
	USH matchhead = 0;
	USH curmatchlength = 0;
	USH curmatchdist = 0;
	//与写标记相关变量
	UCH chflag = 0;
	UCH bitcount = 0;
	bool islen = false;
	FILE *fout = fopen("2.lzp", "wb");
	assert(fout);
	FILE* foutf = fopen("3.txt", "wb");
	assert(foutf);
	//一个一个字符计算的
	//处理前两个字节
	for (USH i = 0; i < MIN_MATCH - 1; ++i) {
		_ht.hashfunc(hashaddr, _pwin[i]);
	}
	//
	//压缩
	while (lookahead) {
		curmatchdist = 0;
		curmatchlength = 0;
		//1.将当前字符串插入哈希表，并获取匹配头
		_ht.insert(matchhead, _pwin[start + 2],start,hashaddr);
		//2.验证在查找缓冲区中是否找到匹配
		if (matchhead != 0) {
			//找最长匹配,带出长度距离对
			curmatchlength = longestmatch(matchhead, curmatchdist,start);
		}
		if (curmatchlength < MIN_MATCH) {
			//没找到
			//将start位置字符写入压缩文件
			fputc(_pwin[start], fout);
			//写当前原字符对应的标记
			writeflage(foutf,chflag,bitcount,false);
			++start;
			lookaheadsfn =::mergefile(FILE* fout,ULL filesize) {
长度距离对写入压缩文件  
			//先写长度，在写距离。为了和Huffman结合
			UCH chlen = curmatchlength - 3;
			fputc(chlen, fout);//最少是3个，所以用0表示3
			fwrite(&curmatchdist, sizeof(curmatchdist), 1, fout)er	chflag <<= (8 - b  lopen("4.txt", "wb");WSIZE, fin);
	}#in;
		r//dlibdlibeek(计算的) {
b")前两ibeeatchfor (
	/ing & /in_MATCH) {
&&(1; ++ichlengt淮rfilf	lo(rfilepat小
	FILi]rt位置字符凶址		}
	}
	if (natchlen = curmatc大于wsize -wsize
		fseek(fin, 0, SEEze
		//1.将
	//压缩
le (
			，并ize_:end头engt淮 0;
		//1.将当前字符串插入哈写龋表并获取匹配头
		_ht//2.验证在_pwi/2.验证在欠<< ":ende
	if (
	_ht.upd!_str(), "rb氩檎最长:end,带出SH hashaddize), seek(fin, 0, SEElongestek(fi	//1.将当前e;
	FILE *fo并获hlength = pen faseek(fin, 0, S_MATCH) {
r(), "rb氩没<< "= 0; i < 并获个数压缩r = 0;
	USHad(&flagsiz址串插入哈表
	assert(fout)
	//(files对应的;
	FILE* foutf = fopen("3
			//b");
	aslen, ssert(f++迦牍outf);
	//一个, 0 - sieof(flagsize) - sizeof<< "了= 0; i < SH hashaddr = 0;
	USH  = 0; i 
		SH hxt"谛asha。为了和H;
man结合= 0; /读取w) {
	aseek(fin, 0, S-trfilepalagsize,n, 恚
	ass//最少是3个，
		s用0表示3ilepalt<filese;
	FILE *fo	if (bite;
	FILE *f 0) {
			chfla(fout);
	FILE* foutf = fopen("3取wsize,接掖翱
, ullptoutf);
	//一个 -
	aseek(fin, 0, s//撼迩
		//2.验证在查找while (; i < 	whi:end的压缩
按三ibdl组将其le (到
			中e (; nsert(matchhead, //
	//压缩
	while (ilesize), SEert(matchhead,
	fread( + 2],start,gt淮 0;
		//1.将当前字符串插入哈+１碲
	me取匹配头
		_ht; nsert(matchhead,  - sizeof(( + 2],start,zeof(//检测
		//2.验证在查找环ND); = pen fnatchlen =e(&flagsLOOKHEAD)&&) {
				//c
	freadag & 0x80) {e(fiatchlen = tart,zeof米址卸孕慈皇不足8位 1, fou右窗口
	>hea&&接掖翱
	< 8 curmatc记指针移动(8S-t右窗口
UCH matagsize,size,}#in;
		r米址薪buff	USH+对写入压合并tchftr == fin2;
		r//开始解压/写入顾跏据
				bitcount = ize) - flagsize-sizeof(filesiin2;
		
	fclose(f);
	lo
void LZ77::mergefile(FILE* fout,ULL filesize) {
长度距离对写入压缩文件  
			//先写长度，在写距离。为了和Huffman结合
			UCH chlen = curmatchlength - 3;
			fputc(chlen, fout);//最少是3个，所以用0表示3
			fwrite(&curmatchdist, sizeof(curmatchdist), 1, fout)hlen = curma2chlength - 3;
			fputc(chlen, fout);//最少是3个，所以用0表示3
	size_size +agsize f, 1, rdsize, f
				start++;
				_ht.inserttart+2], start,hashaddr);
				ze) {
		if (bitcount == 0) {
rt++;
		}ize_对写一while (t(fout);
	FILE* f = fo	if ((lookahead <= MIN_LOOKHEAD)&&(t.inserttart+2], start,hashaddr);
				ULL encodecount = 0;
	while (ert++;
		}将对写缩文移动到对写buff的起始个数 fo	if ((lookahead <= MIN_LOOKHEAD)&&(LOOKHEAD-t.inserttart+2], start,hashaddr//开始昙俏皇
			 = 昙俏皇buff;
 (8 - b  litcount);
		fputc(WSIZE, fin);
	}#include"LZ77.hitcount);
		fputc(ist),ist, S:end内f;
 fout)hlen = curchlength - 3;
			fputc(chlen, fout);//最少是3个，所以用0表示3
置到右窗口
	if (!fe/读取wsize个数据放置到 SEEK据放置到}
	FILE* f新哈希表
	_hze -wsize
	f, 1th.c_str(), size
	ze), SEth.c_str(),<缩数据
	FILE*, fou右窗口
	 cutr(), "rbwsize个_END);
	++;
	记数据的起个8length = pen fawsize& 0x8tr(), "rb氩是ILE, "rb}
	FILE* f_END);
	fr写rfilepath.c_str(), 在}
	FILEfilepaltr == fin2),is
		s得清空/2.验ilepal;
			
	FILE *fo	if (bit
	FILE *f 0) {

	fread(&fistㄎ蝗胙顾跷募 palif ((lahe-
	FILE *fo	tart,hashaddrsize), SE}
	FILE
	fread(//ch为255，因为buff在/2.验郑还没	 = fread( SEEK_END);
		_ht; lagsize, sizeof(flagsb}
	FILE, 0 - sih = pflagsize) - sizeof(files, "rbw* f_END);
	frfilepalagsize, sizeof(flagsth.c_str(),,start,zeof(c记指针移动1tart,数据的起, 0 - )
		tcount = frfile	tcount = ++;
	- flagsize-sizeof(filesi
		
	fclose(f);
//开始解压 (8 - b  l,f, 1, rdsize
	fre			fwriteopen("4.txt", "wb");ist), 1,t(fout);
	FILE* f = fo置*c(fin2);
clos		}
		std:]e
	ze), SEullpthlength(fout)
	USH LE* fin,sflag = 0;
	UCstd:{

	
		_hten f0	 cu
	USH <= 1t,lagkCH matt<fileflag = 0;
	UC
	USH  sizeof(flag;
	FILE*在
	USH 0 - )
		t<filesiULL encodecount = 0;
	while (eze-sizeoft<filesize) {
		if (bitcount == 0) {
ze-sizeo1);
	fclflag = 0;file	tcount = i
		
	fclose(f);
ag & 0x80) {			fwrite,h(fout&windows(FI)e) {
将le (mabuff搬移到odecount += matchlen;
			fflush(fout);//所以得清空缓冲区
			fread(&matchdist, sizeof(matchdist), 1, fin1);
			//定位文件指针
			fseek(f, 0-matchdist, SEEK_END);
			while (matchlen) {
				//ch为255，因为数据在缓冲区，还没写入
				ch = fgetc(f);
					
	f		//原字"(f);.h"
			//原字iourmeam
			//原字in);
ch = f	//原字;//libch = fpragma warnE* (E *able:4996<= (f);
	fclos
		:还没(s		}
		= fge*2]s
		,ad((;//所{
	f(f);
~	fclosh为251);
	fcl还没
		还没los)hlen 
		
	fclose(f);
o
void LZ77::mergefile(FILE* fout,ULL filesize) {
如果size +	fseATCH) {
&xt"虿猾b")
		}ize_ze +agsize 			fwrite&curmatchdist, sizeof(curmatchdist), 1, fout)hlen = curmachlength - 3;
			fputc(chlen, fout);//最少是3个，所以用0表示3
	fclose(finf);
}
hashaddrf, 1, rdsize, fftellt = izof(ize +的指针
 fou, rdsize,(&flags) {
r(), "rh - 3;
			fpu, rd smallfout);//最少是3个，所以用0表示3
	s从0;
	USHt, Sdlib/2.验值buff;
	fclose(finf);
}
SET), 1,t(fout)windows(FILE* fin,shlen;
ch 2 * = fgetc(f);氩实际t, S多少鹿希表迦牍size
	//小_pwie 置为0
	//１怼匹配头* f新哈希表
	_hs(FILE*南卤
	//大于wsin, 0, SEEze
	
	//大于wsize -wsize
	//小t);
	e 置为0
	//读取wsize个数据放置到右窗口
	if (!febool isILE* f_en, lude"LZ7 *b  litcount);2.lzputc(WSIZE, fin);
	}#include"LZ77.hin2;pen("4.txt", "wb");WSIZE, fin);
	}#in
		_h//dlibdlibiles计算的3
	sb")前两ibilatchfor (
	/i	if (/i	_MATCH) {
&&(1; ++ir(), "rad(&∑ヅf	lo(∑ヅ渫白址串i]
		r米址凶址星位孰
ze), SEindows(FI)curmatc大于wsize -wsize
	, seek(fin, 0, SEEze
	,//1.将
	//压缩
le (
			，并ize_:end头, "rad(& 0;
		//1.将当前字符串插入哈写龋表
	me取匹配头
		_ht//2.验证在_pwi/2.验证在欠<< ":end	_hten f
	_hs(FIL!cutr(), "rbof<<最长:end,带出SH hashadd, "rbseek(fin, 0, SEElongestek(fi	//1.将当前e;
	FILE *fo
	me tart,zeofpen faseek(fin, 0, S_MATCH) {
r(), "rbof没<< "e (; i < 
	me个数压缩r = 0;
	USHilepalagsiz址串插入哈表
			chfla(fout)
	//(files对应的;
	FILE* foutf = fopen("3e,size,右窗口
,_en, chfla(f++迦牍outf);
	//一个, 0 - si = pflagsize) - sizeof<< "了e (; i < SH hashaddr = 0;
	USH  e (; i 
		SH hxt"谛asha。为了和H 0;man结合e (; /读取wILE* faseek(fin, 0, S-rfilepalagsize,n, 碲
			ch//最少是3个，
		s用0表示3ilepalt<filese;
	FILE *fo	if (bite;
	FILE *f 0) {
ze-sizeo(fout);
	FILE* foutf = fopen("3取wsize,接掖翱
, ullptoutf);
	//一个 - faseek(fin, 0, h//撼迩
		//2.验证在查找while (; i < 	whi:end的压缩
按三ibdl组将其le (到
			中e (; nsert(matchhead, //
	//压缩
	while (ddrsize), SEert(matchhead,
	fread( + 2],start,"rad(& 0;
		//1.将当前字符串插入哈+１眄迦牍取匹配头
		_ht; nsert(matchhead,  - sih = p( + 2],start,h = p//检测
		//2.验证在查找环ND);eofpen fEindows(FI,(&flagsLOOKHEAD)&&) {
				//c
	freadag & 0x80) {e(fiindows(FI)tart,h = 米址卸孕慈皇不足8位
 fou右窗口
	>hea&&接掖翱
	< 8)curmatc记指针移动(8S-扔掖翱
f(flag;agsize,size,}#in
		_h米址薪buff	USH+对写入压合并tchftr == fin2
		_h//开始解压b  l,1, rdsizefile	tcount = +;
	- flagsize-sizeof(filesiin2
		_
	fclose(f);
	lo
void LZ77::mergefile(FILE* fout,ULL filesize) {
长度距离对写入压缩文件  
			//先写长度，在写距离。为了和Huffman结合
			UCH chlen = curmatchlength - 3;
			fputc(chlen, fout);//最少是3个，所以用0表示3
			fwrite(&curmatchdist, sizeof(curmatchdist), 1, fout)hlen = curma2chlength - 3;
			fputc(chlen, fout);//最少是3个，所以用0表示3
	}ize_(ize +agsize f, 1, rdsize, f = fo	if ((lookahead <= MIN_Ltart+2], start,hashaddr);
				ze) {
		if (bitcount == 0) {
rt++;
		}ize_对写一while (t(fout);
	FILE* f = fo	if ((lookahead <= MIN_LOOKHEAD)&&(<= MIN_Ltart+2], start,hashaddr);
				ULL encodecount = 0;
	while (ert++;
		}将对写缩文移动到对写buff的起始个数 fo	if ((lookahead <= MIN_LOOKHEAD)&&(LOOKHEAD-<= MIN_Ltart+2], start,hashaddr//开始昙俏皇
			 = 昙俏皇buff;
"LZ77.hin2itcount);
		fputc(WSIZE, fin);
	}#include"LZ77.hitcount);
		fputc(ist),ist, S:end内f;
 fout)hlen = curchlength - 3;
			fputc(chlen, fout);//最少是3个，所以用0表示3
置到右窗口
	if (!fe/读取wsize个数据放置到w* f据放置到}
	FILE* f新哈希表
	_hze -wsize
	f, 1th.c_str(), size
	ze), SEth.c_str(),<, rdsize
	fre
 fou右窗口
	 cutr(), "rbwsize个_END);
	++;
	t,数据的起个8tart,zeofpen fawsize& 0x8tr(), "rbof是ILE, "rb}
	FILE* f_END);
	fr写rfilepath.c_str(), 在}
	FILEfilepaltr == fin2),is
		s得清空/2.验ilepal;
			
	FILE *fo	if (bit
	FILE *f 0) {

	frfilepaistㄎ蝗胙顾跷募 palif ((lahe-
	FILE *fo	tart,hashaddrsize), SE}
	FILE
	fread(//ch为255，因为buff在/2.验郑还没	 = fread(w* f_END);
		_ht; lagsize, sizeof(flagsb}
	FILE, 0 - sizeofpflagsize) - sizeof(files, "rbw* f_END);
	frfilepalagsize, sizeof(flagsth.c_str(),,start,h = pc记指针移动1tart,数据的起, 0 - 3
	tcount = frfile	tcount = ++;
	- flagsize-sizeof(filesi
		_
	fclose(f);
//开始解压"LZ77.hin2,f, 1, rdsize
	fre			fwrite;pen("4.txt", "wb");ist), 1,t(fout);
	FILE* f = fo置*lflag = 0;los		}
		std:]e
	ze), SEullpthlength(fout)
	USH LE* fin,sflag = 0;
	UCstd:{

	
		_hten f0	 cu
	USH s
		t,lagk(flag;t<fileflag = 0;
	UC
	USH  sizeof(flag;
	FILE*在
	USH 0 - 3
	t<filesiULL encodecount = 0;
	while (eze-sizeoft<filesize) {
		if (bitcount == 0) {
ze-sizeo1);
	fclflag = 0;file	tcount = i
		_
	fclose(f);
ag & 0x80) {			fwrite,h(fout&windows(FI)e) {
将le (mabuff搬移到odecount += matchlen;
			fflush(fout);//所以得清空缓冲区
			fread(&matchdist, sizeof(matchdist), 1, fin1);
			//定位文件指针
			fseek(f, 0-matchdist, SEEK_END);
			while (matchlen) {
				//ch为255，因为数据在缓冲区，还没写入
				ch = fgetc(f);
			f	//原字"(f);.h"= f	//原字iourmeam = f	//原字in);
ch = f	//原字;//libch = fpragma warnE* (E *able:4996s
	(f);
	fclos
		:还没(s		}
		= fge*2]s
		,ad((;//所{
	f(f);
~	fclosh为251);
	fcl还没
		还没los)hlen 		_
	fclose(f);
o
void LZ77::mergefile(FILE* fout,ULL filesize) {
如果(ize +	fseATCH) {
&xt"虿淮b")
		}ize_ze +agsize 			fwrite&curmatchdist, sizeof(curmatchdist), 1, fout)hlen = curmachlength - 3;
			fputc(chlen, fout);//最少是3个，所以用0表示3
	fclose(finf);
}
hashaddrf, 1, rdsize, fftellt = +;of(ize +的指针
 fou, rdsize,(&flags) {
r(), "rh - 3;
			fpu, rd smallfout);//最少是3个，所以用0表示3
	}从0;
	USHt, Sdlib/2.验值buff;
	fclose(finf);
}
SET), 1,t(fout)windows(FILE* fin,shlen;
ch 2 * = fgetc(f);of实际t, S多少鹿希表迦牍size
	//小_pwie 置为0
	//１怼匹配头* f新哈希表
	_hs(FILE*ze
	
	//大于wsin, 0, SEEze
	
	//大于wsize -wsize
	//小t);
	e 置为0
	//读取wsize个数据放置到右窗口
	if (!febool isILE* f_en, lude"LZ7 *hin2itcount);2.lzputc(WSIZE, fin);
	}#include"LZ77.hin2pen("4.txt", "wb");WSIZE, fin);
	}#in
		_h//dlibdlibiles计算的3
	}b")前两ibilatchfor (
	/i	if (/i	_MATCH) {
&&(1; ++ir(), "rad(&∑ヅf	lo(∑ヅ渫白址串i]
		_h米址凶址星位孰
ze), SEindows(FI)curmatc大于wsize -wsize
	bseek(fin, 0, SEEze
	b//1.将
	//压缩
le (
			，并ize_:end头, "rad(& 0;
		//1.将当前字符串插入哈写龋表迦牍取匹配头
		_ht//2.验证在_pwi/2.验证在欠<< ":end	_hten f
	_hs(FIL!cutr(), "rbof<<最长:end,带出SH hashadd, "rbseek(fin, 0, SEElongestek(fi	//1.将当前e;
	FILE *fo迦牍)tart,h = pen faseek(fin, 0, S_MATCH) {
r(), "rbof没<< "e (; i < 迦牍个数压缩r = 0;
	USHilepalagsiz址串插入哈表
ze-sizeo(fout)
	//(files对应的;
	FILE* foutf = fopen("3e,size,右窗口
,_en, sizeo(f++迦牍outf);
	//一个, 0 - sieofpflagsize) - sizeof<< "了e (; i < SH hashaddr = 0;
	USH  e (; i 
		SH hxt"谛asha。为了和H 0;man结合e (; /读取wILE* faseek(fin, 0, S-rfilepalagsize,n, 眄
ze-si//最少是3个，
		s用0表示3ilepalt<filese;
	FILE *fo	if (bite;
	FILE *f 0) {
ze-sizeo(fout);
	FILE* foutf = fopen("3取wsize,接掖翱
, ullptoutf);
	//一个 - faseek(fin, 0, i//撼迩
		//2.验证在查找while (; i < 	whi:end的压缩
按三ibdl组将其le (到
			中e (; nsert(matchhead, //
	//压缩
	while (ddrsize), SEert(matchhead,
	fread( + 2],start,"rad(& 0;
		//1.将当前字符串插入哈+１眄迦牍取匹配头
		_ht; nsert(matchhead,  - sizeofp( + 2],start,zeofp//检测
		//2.验证在查找环ND); = pen fEindows(FI,(&flagsLOOKHEAD)&&) {
				//c
	freadag & 0x80) {e(fiindows(FI)tart,zeof米址卸孕慈皇不足8位
 fou右窗口
	>hea&&接掖翱
	< 8)curmatc记指针移动(8S-扔掖翱
f(flag;agsize,size,}#in
		_h米址薪buff	USH+对写入压合并tchftr == fin2
		_h//开始解压hin2,1, rdsizefile	tcount = +;
	- flagsize-sizeof(filesiin2
		_
	fclose(f);
	lo
void LZ77::mergefile(FILE* fout,ULL filesize) {
长度距离对写入压缩文件  
			//先写长度，在写距离。为了和Huffman结合
			UCH chlen = curmatchlength - 3;
			fputc(chlen, fout);//最少是3个，所以用0表示3
			fwrite(&curmatchdist, sizeof(curmatchdist), 1, fout)hlen = curma2chlength - 3;
			fputc(chlen, fout);//最少是3个，所以用0表示3
	}ize_(ize +agsize f, 1, rdsize, f = fo	if ((lookahead <= MIN_Ltart+2], start,hashaddr);
				ze) {
		if (bitcount == 0) {
rt++;
		}ize_对写一while (t(fout);
	FILE* f = fo	if ((lookahead <= MIN_LOOKHEAD)&&(<= MIN_Ltart+2], start,hashaddr);
				ULL encodecount = 0;
	while (ert++;
		}将对写缩文移动到对写buff的起始个数 fo	if ((lookahead <= MIN_LOOKHEAD)&&(LOOKHEAD-<= MIN_Ltart+2], start,hashaddr//开始昙俏皇
			 = 昙俏皇buff;
"LZ77.hin2itcount);
		fputc(WSIZE, fin);
	}#include"LZ77.hitcount);
		fputc(ist),ist, S:end内f;
 fout)hlen = curchlength - 3;
			fputc(chlen, fout);//最少是3个，所以用0表示3
置到右窗口
	if (!fe/读取wsize个数据放置到w* f据放置到}
	FILE* f新哈希表
	_hze -wsize
	f, 1th.c_str(), size
	ze), SEth.c_str(),<, rdsize
	fre
 fou右窗口
	 cutr(), "rbwsize个_END);
	++;
	t,数据的起个8tart,h = pen fawsize& 0x8tr(), "rbof是ILE, "rb}
	FILE* f_END);
	fr写rfilepath.c_str(), 在}
	FILEfilepaltr == fin2),is
		s得清空/2.验ilepal;
			
	FILE *fo	if (bit
	FILE *f 0) {

	frfilepaistㄎ蝗胙顾跷募 palif ((lahe-
	FILE *fo	tart,hashaddrsize), SE}
	FILE
	fread(//ch为255，因为buff在/2.验郑还没	 = fread(w* f_END);
		_ht; lagsize, sizeof(flagsb}
	FILE, 0 - sih = pflagsize) - sizeof(files, "rbw* f_END);
	frfilepalagsize, sizeof(flagsth.c_str(),,start,zeofpc记指针移动1tart,数据的起, 0 - 3
	tcount = frfile	tcount = ++;
	- flagsize-sizeof(filesi
		_
	fclose(f);
//开始解压"LZ77.hin2,f, 1, rdsize
	fre			fwritepen("4.txt", "wb");ist), 1,t(fout);
	FILE* f = fo置*lflag = 0;los		}
		std:]e
	ze), SEullpthlength(fout)
	USH LE* fin,sflag = 0;
	UCstd:{

	
		_hten f0	 cu
	USH s
		t,lagk(flag;t<fileflag = 0;
	UC
	USH  sizeof(flag;
	FILE*在
	USH 0 - 3
	t<filesiULL encodecount = 0;
	while (eze-sizeoft<filesize) {
		if (bitcount == 0) {
ze-sizeo1);
	fclflag = 0;file	tcount = i
		_
	fclose(f);
ag & 0x80) {			fwrite,h(fout&windows(FI)e) {
将le (mabuff搬移到odecount += matchlen;
			fflush(fout);//所以得清空缓冲区
			fread(&matchdist, sizeof(matchdist), 1, fin1);
			//定位文件指针
			fseek(f, 0-matchdist, SEEK_END);
			while (matchlen) {
				//ch为255，因为数据在缓冲区，还没写入
				ch = fgetc(f);
				_
	ff	//原字"(f);.h"= f	//原字iourmeam = f	//原字in);
ch = f	//原字;//libch = fpragma warnE* (E *able:4996s
	(f);
	fclos
		:还没(s		}
		= fge*2]s
		,ad((;//所{
	f(f);
~	fclosh为251);
	fcl还没
		还没los)hlen 		_
	fclose(f);
o
void LZ77::mergefile(FILE* fout,ULL filesize) {
如果(ize +	fseATCH) {
&xt"虿淮b")
		}ize_ze +agsize 			fwrite&curmatchdist, sizeof(curmatchdist), 1, fout)hlen = curmachlength - 3;
			fputc(chlen, fout);//最少是3个，所以用0表示3
	fclose(finf);
}
hashaddrf, 1, rdsize, fftellt = +;of(ize +的指针
 fou, rdsize,(&flags) {
r(), "rh - 3;
			fpu, rd smallfout);//最少是3个，所以用0表示3
	}从0;
	USHt, Sdlib/2.验值buff;
	fclose(finf);
}
SET), 1,t(fout)windows(FILE* fin,shlen;
ch 2 * = fgetc(f);of实际t, S多少鹿希表迦牍size
	//小_pwie 置为0
	//１怼匹配头* f新哈希表
	_hs(FILE*ze
	
	//大于wsin, 0, SEEze
	
	//大于wsize -wsize
	//小t);
	e 置为0
	//读取wsize个数据放置到右窗口
	if (!febool isILE* f_en, lude"LZ7 *hin2itcount);2.lzputc(WSIZE, fin);
	}#include"LZ77.hin2pen("4.txt", "wb");WSIZE, fin);
	}#in
		_h//dlibdlibiles计算的3
	}b")前两ibilatchfor (
	/i	if (/i	_MATCH) {
&&(1; ++ir(), "rad(&∑ヅf	lo(∑ヅ渫白址串i]
		_h米址凶址星位孰
ze), SEindows(FI)curmatc大于wsize -wsize
	bseek(fin, 0, SEEze
	b//1.将
	//压缩
le (
			，并ize_:end头, "rad(& 0;
		//1.将当前字符串插入哈写龋表迦牍取匹配头
		_ht//2.验证在_pwi/2.验证在欠<< ":end	_hten f
	_hs(FIL!cutr(), "rbof<<最长:end,带出SH hashadd, "rbseek(fin, 0, SEElongestek(fi	//1.将当前e;
	FILE *fo迦牍)tart,zeofpen faseek(fin, 0, S_MATCH) {
r(), "rbof没<< "e (; i < 迦牍个数压缩r = 0;
	USHilepalagsiz址串插入哈表
ze-sizeo(fout)
	//(files对应的;
	FILE* foutf = fopen("3e,size,右窗口
,_en, sizeo(f++迦牍outf);
	//一个, 0 - si = pflagsize) - sizeof<< "了e (; i < SH hashaddr = 0;
	USH  e (; i 
		SH hxt"谛asha。为了和H 0;man结合e (; /读取wILE* faseek(fin, 0, S-rfilepalagsize,n, 眄
ze-si//最少是3个，
		s用0表示3ilepalt<filese;
	FILE *fo	if (bite;
	FILE *f 0) {
ze-sizeo(fout);
	FILE* foutf = fopen("3取wsize,接掖翱
, ullptoutf);
	//一个 - faseek(fin, 0, i//撼迩
		//2.验证在查找while (; i < 	whi:end的压缩
按三ibdl组将其le (到
			中e (; nsert(matchhead, //
	//压缩
	while (ddrsize), SEert(matchhead,
	fread( + 2],start,"rad(& 0;
		//1.将当前字符串插入哈+１眄迦牍取匹配头
		_ht; nsert(matchhead,  - sih = p( + 2],start,h = p//检测
		//2.验证在查找环ND);eofpen fEindows(FI,(&flagsLOOKHEAD)&&) {
				//c
	freadag & 0x80) {e(fiindows(FI)tart,h = 米址卸孕慈皇不足8位
 fou右窗口
	>hea&&接掖翱
	< 8)curmatc记指针移动(8S-扔掖翱
f(flag;agsize,size,}#in
		_h米址薪buff	USH+对写入压合并tchftr == fin2
		_h//开始解压hin2,1, rdsizefile	tcount = +;
	- flagsize-sizeof(filesiin2
		_
	fclose(f);
	lo
void LZ77::mergefile(FILE* fout,ULL filesize) {
长度距离对写入压缩文件  
			//先写长度，在写距离。为了和Huffman结合
			UCH chlen = curmatchlength - 3;
			fputc(chlen, fout);//最少是3个，所以用0表示3
			fwrite(&curmatchdist, sizeof(curmatchdist), 1, fout)hlen = curma2chlength - 3;
			fputc(chlen, fout);//最少是3个，所以用0表示3
	}ize_(ize +agsize f, 1, rdsize, f = fo	if ((lookahead <= MIN_Ltart+2], start,hashaddr);
				ze) {
		if (bitcount == 0) {
rt++;
		}ize_对写一while (t(fout);
	FILE* f = fo	if ((lookahead <= MIN_LOOKHEAD)&&(<= MIN_Ltart+2], start,hashaddr);
				ULL encodecount = 0;
	while (ert++;
		}将对写缩文移动到对写buff的起始个数 fo	if ((lookahead <= MIN_LOOKHEAD)&&(LOOKHEAD-<= MIN_Ltart+2], start,hashaddr//开始昙俏皇
			 = 昙俏皇buff;
"LZ77.hin2itcount);
		fputc(WSIZE, fin);
	}#include"LZ77.hitcount);
		fputc(ist),ist, S:end内f;
 fout)hlen = curchlength - 3;
			fputc(chlen, fout);//最少是3个，所以用0表示3
置到右窗口
	if (!fe/读取wsize个数据放置到w* f据放置到}
	FILE* f新哈希表
	_hze -wsize
	f, 1th.c_str(), size
	ze), SEth.c_str(),<, rdsize
	fre
 fou右窗口
	 cutr(), "rbwsize个_END);
	++;
	t,数据的起个8tart,zeofpen fawsize& 0x8tr(), "rbof是ILE, "rb}
	FILE* f_END);
	fr写rfilepath.c_str(), 在}
	FILEfilepaltr == fin2),is
		s得清空/2.验ilepal;
			
	FILE *fo	if (bit
	FILE *f 0) {

	frfilepaistㄎ蝗胙顾跷募 palif ((lahe-
	FILE *fo	tart,hashaddrsize), SE}
	FILE
	fread(//ch为255，因为buff在/2.验郑还没	 = fread(w* f_END);
		_ht; lagsize, sizeof(flagsb}
	FILE, 0 - sizeofpflagsize) - sizeof(files, "rbw* f_END);
	frfilepalagsize, sizeof(flagsth.c_str(),,start,h = pc记指针移动1tart,数据的起, 0 - 3
	tcount = frfile	tcount = ++;
	- flagsize-sizeof(filesi
		_
	fclose(f);
//开始解压"LZ77.hin2,f, 1, rdsize
	fre			fwritepen("4.txt", "wb");ist), 1,t(fout);
	FILE* f = fo置*lflag = 0;los		}
		std:]e
	ze), SEullpthlength(fout)
	USH LE* fin,sflag = 0;
	UCstd:{

	
		_hten f0	 cu
	USH s
		t,lagk(flag;t<fileflag = 0;
	UC
	USH  sizeof(flag;
	FILE*在
	USH 0 - 3
	t<filesiULL encodecount = 0;
	while (eze-sizeoft<filesize) {
		if (bitcount == 0) {
ze-sizeo1);
	fclflag = 0;file	tcount = i
		_
	fclose(f);
ag & 0x80) {			fwrite,h(fout&windows(FI)e) {
将le (mabuff搬移到odecount += matchlen;
			fflush(fout);//所以得清空缓冲区
			fread(&matchdist, sizeof(matchdist), 1, fin1);
			//定位文件指针
			fseek(f, 0-matchdist, SEEK_END);
			while (matchlen) {
				//ch为255，因为数据在缓冲区，还没写入
				ch = fgetc(f);
			f	//原字"(f);.h"= f	//原字iourmeam = f	//原字in);
ch = f	//原字;//libch = fpragma warnE* (E *able:4996s
	(f);
	fclos
		:还没(s		}
		= fge*2]s
		,ad((;//所{
	f(f);
~	fclosh为251);
	fcl还没
		还没los)hlen 		_
	fclose(f);
o
void LZ77::mergefile(FILE* fout,ULL filesize) {
如果(ize +	fseATCH) {
&xt"虿淮b")
		}ize_ze +agsize 			fwrite&curmatchdist, sizeof(curmatchdist), 1, fout)hlen = curmachlength - 3;
			fputc(chlen, fout);//最少是3个，所以用0表示3
	fclose(finf);
}
hashaddrf, 1, rdsize, fftellt = +;of(ize +的指针
 fou, rdsize,(&flags) {
r(), "rh - 3;
			fpu, rd smallfout);//最少是3个，所以用0表示3
	}从0;
	USHt, Sdlib/2.验值buff;
	fclose(finf);
}
SET), 1,t(fout)windows(FILE* fin,shlen;
ch 2 * = fgetc(f);of实际t, S多少鹿希表迦牍size
	//小_pwie 置为0
	//１怼匹配头* f新哈希表
	_hs(FILE*ze
	
	//大于wsin, 0, SEEze
	
	//大于wsize -wsize
	//小t);
	e 置为0
	//读取wsize个数据放置到右窗口
	if (!febool isILE* f_en, lude"LZ7 *hin2itcount);2.lzputc(WSIZE, fin);
	}#include"LZ77.hin2pen("4.txt", "wb");WSIZE, fin);
	}#in
		_h//dlibdlibiles计算的3
	}b")前两ibilatchfor (
	/i	if (/i	_MATCH) {
&&(1; ++ir(), "rad(&∑ヅf	lo(∑ヅ渫白址串i]
		_h米址凶址星位孰
ze), SEindows(FI)curmatc大于wsize -wsize
	bseek(fin, 0, SEEze
	b//1.将
	//压缩
le (
			，并ize_:end头, "rad(& 0;
		//1.将当前字符串插入哈写龋表迦牍取匹配头
		_ht//2.验证在_pwi/2.验证在欠<< ":end	_hten f
	_hs(FIL!cutr(), "rbof<<最长:end,带出SH hashadd, "rbseek(fin, 0, SEElongestek(fi	//1.将当前e;
	FILE *fo迦牍)tart,h = pen faseek(fin, 0, S_MATCH) {
r(), "rbof没<< "e (; i < 迦牍个数压缩r = 0;
	USHilepalagsiz址串插入哈表
ze-sizeo(fout)
	//(files对应的;
	FILE* foutf = fopen("3e,size,右窗口
,_en, sizeo(f++迦牍outf);
	//一个, 0 - sieofpflagsize) - sizeof<< "了e (; i < SH hashaddr = 0;
	USH  e (; i 
		SH hxt"谛asha。为了和H 0;man结合e (; /读取wILE* faseek(fin, 0, S-rfilepalagsize,n, 眄
ze-si//最少是3个，
		s用0表示3ilepalt<filese;
	FILE *fo	if (bite;
	FILE *f 0) {
ze-sizeo(fout);
	FILE* foutf = fopen("3取wsize,接掖翱
, ullptoutf);
	//一个 - faseek(fin, 0, i//撼迩
		//2.验证在查找while (; i < 	whi:end的压缩
按三ibdl组将其le (到
			中e (; nsert(matchhead, //
	//压缩
	while (ddrsize), SEert(matchhead,
	fread( + 2],start,"rad(& 0;
		//1.将当前字符串插入哈+１眄迦牍取匹配头
		_ht; nsert(matchhead,  - sizeofp( + 2],start,zeofp//检测
		//2.验证在查找环ND); = pen fEindows(FI,(&flagsLOOKHEAD)&&) {
				//c
	freadag & 0x80) {e(fiindows(FI)tart,zeof米址卸孕慈皇不足8位
 fou右窗口
	>hea&&接掖翱
	< 8)curmatc记指针移动(8S-扔掖翱
f(flag;agsize,size,}#in
		_h米址薪buff	USH+对写入压合并tchftr == fin2
		_h//开始解压hin2,1, rdsizefile	tcount = +;
	- flagsize-sizeof(filesiin2
		_
	fclose(f);
	lo
void LZ77::mergefile(FILE* fout,ULL filesize) {
长度距离对写入压缩文件  
			//先写长度，在写距离。为了和Huffman结合
			UCH chlen = curmatchlength - 3;
			fputc(chlen, fout);//最少是3个，所以用0表示3
			fwrite(&curmatchdist, sizeof(curmatchdist), 1, fout)hlen = curma2chlength - 3;
			fputc(chlen, fout);//最少是3个，所以用0表示3
	}ize_(ize +agsize f, 1, rdsize, f = fo	if ((lookahead <= MIN_Ltart+2], start,hashaddr);
				ze) {
		if (bitcount == 0) {
rt++;
		}ize_对写一while (t(fout);
	FILE* f = fo	if ((lookahead <= MIN_LOOKHEAD)&&(<= MIN_Ltart+2], start,hashaddr);
				ULL encodecount = 0;
	while (ert++;
		}将对写缩文移动到对写buff的起始个数 fo	if ((lookahead <= MIN_LOOKHEAD)&&(LOOKHEAD-<= MIN_Ltart+2], start,hashaddr//开始昙俏皇
			 = 昙俏皇buff;
"LZ77.hin2itcount);
		fputc(WSIZE, fin);
	}#include"LZ77.hitcount);
		fputc(ist),ist, S:end内f;
 fout)hlen = curchlength - 3;
			fputc(chlen, fout);//最少是3个，所以用0表示3
置到右窗口
	if (!fe/读取wsize个数据放置到w* f据放置到}
	FILE* f新哈希表
	_hze -wsize
	f, 1th.c_str(), size
	ze), SEth.c_str(),<, rdsize
	fre
 fou右窗口
	 cutr(), "rbwsize个_END);
	++;
	t,数据的起个8tart,h = pen fawsize& 0x8tr(), "rbof是ILE, "rb}
	FILE* f_END);
	fr写rfilepath.c_str(), 在}
	FILEfilepaltr == fin2),is
		s得清空/2.验ilepal;
			
	FILE *fo	if (bit
	FILE *f 0) {

	frfilepaistㄎ蝗胙顾跷募 palif ((lahe-
	FILE *fo	tart,hashaddrsize), SE}
	FILE
	fread(//ch为255，因为buff在/2.验郑还没	 = fread(w* f_END);
		_ht; lagsize, sizeof(flagsb}
	FILE, 0 - sih = pflagsize) - sizeof(files, "rbw* f_END);
	frfilepalagsize, sizeof(flagsth.c_str(),,start,zeofpc记指针移动1tart,数据的起, 0 - 3
	tcount = frfile	tcount = ++;
	- flagsize-sizeof(filesi
		_
	fclose(f);
//开始解压"LZ77.hin2,f, 1, rdsize
	fre			fwritepen("4.txt", "wb");ist), 1,t(fout);
	FILE* f = fo置*lflag = 0;los		}
		std:]e
	ze), SEullpthlength(fout)
	USH LE* fin,sflag = 0;
	UCstd:{

	
		_hten f0	 cu
	USH s
		t,lagk(flag;t<fileflag = 0;
	UC
	USH  sizeof(flag;
	FILE*在
	USH 0 - 3
	t<filesiULL encodecount = 0;
	while (eze-sizeoft<filesize) {
		if (bitcount == 0) {
ze-sizeo1);
	fclflag = 0;file	tcount = i
		_
	fclose(f);
ag & 0x80) {			fwrite,h(fout&windows(FI)e) {
将le (mabuff搬移到odecount += matchlen;
			fflush(fout);//所以得清空缓冲区
			fread(&matchdist, sizeof(matchdist), 1, fin1);
			//定位文件指针
			fseek(f, 0-matchdist, SEEK_END);
			while (matchlen) {
				//ch为255，因为数据在缓冲区，还没写入
				ch = fgetc(f);
				_
	ff	//原字"(f);.h"= f	//原字iourmeam = f	//原字in);
ch = f	//原字;//libch = fpragma warnE* (E *able:4996s
	(f);
	fclos
		:还没(s		}
		= fge*2]s
		,ad((;//所{
	f(f);
~	fclosh为251);
	fcl还没
		还没los)hlen 		_
	fclose(f);
o
void LZ77::mergefile(FILE* fout,ULL filesize) {
如果(ize +	fseATCH) {
&xt"虿淮b")
		}ize_ze +agsize 			fwrite&curmatchdist, sizeof(curmatchdist), 1, fout)hlen = curmachlength - 3;
			fputc(chlen, fout);//最少是3个，所以用0表示3
	fclose(finf);
}
hashaddrf, 1, rdsize, fftellt = +;of(ize +的指针
 fou, rdsize,(&flags) {
r(), "rh - 3;
			fpu, rd smallfout);//最少是3个，所以用0表示3
	}从0;
	USHt, Sdlib/2.验值buff;
	fclose(finf);
}
SET), 1,t(fout)windows(FILE* fin,shlen;
ch 2 * = fgetc(f);of实际t, S多少鹿希表迦牍size
	//小_pwie 置为0
	//１怼匹配头* f新哈希表
	_hs(FILE*ze
	
	//大于wsin, 0, SEEze
	
	//大于wsize -wsize
	//小t);
	e 置为0
	//读取wsize个数据放置到右窗口
	if (!febool isILE* f_en, lude"LZ7 *hin2itcount);2.lzputc(WSIZE, fin);
	}#include"LZ77.hin2pen("4.txt", "wb");WSIZE, fin);
	}#in
		_h//dlibdlibiles计算的3
	}b")前两ibilatchfor (
	/i	if (/i	_MATCH) {
&&(1; ++ir(), "rad(&∑ヅf	lo(∑ヅ渫白址串i]
		_h米址凶址星位孰
ze), SEindows(FI)curmatc大于wsize -wsize
	bseek(fin, 0, SEEze
	b//1.将
	//压缩
le (
			，并ize_:end头, "rad(& 0;
		//1.将当前字符串插入哈写龋表迦牍取匹配头
		_ht//2.验证在_pwi/2.验证在欠<< ":end	_hten f
	_hs(FIL!cutr(), "rbof<<最长:end,带出SH hashadd, "rbseek(fin, 0, SEElongestek(fi	//1.将当前e;
	FILE *fo迦牍)tart,zeofpen faseek(fin, 0, S_MATCH) {
r(), "rbof没<< "e (; i < 迦牍个数压缩r = 0;
	USHilepalagsiz址串插入哈表
ze-sizeo(fout)
	//(files对应的;
	FILE* foutf = fopen("3e,size,右窗口
,_en, sizeo(f++迦牍outf);
	//一个, 0 - si = pflagsize) - sizeof<< "了e (; i < SH hashaddr = 0;
	USH  e (; i 
		SH hxt"谛asha。为了和H 0;man结合e (; /读取wILE* faseek(fin, 0, S-rfilepalagsize,n, 眄
ze-si//最少是3个，
		s用0表示3ilepalt<filese;
	FILE *fo	if (bite;
	FILE *f 0) {
ze-sizeo(fout);
	FILE* foutf = fopen("3取wsize,接掖翱
, ullptoutf);
	//一个 - faseek(fin, 0, i//撼迩
		//2.验证在查找while (; i < 	whi:end的压缩
按三ibdl组将其le (到
			中e (; nsert(matchhead, //
	//压缩
	while (ddrsize), SEert(matchhead,
	fread( + 2],start,"rad(& 0;
		//1.将当前字符串插入哈+１眄迦牍取匹配头
		_ht; nsert(matchhead,  - sih = p( + 2],start,h = p//检测
		//2.验证在查找环ND);eofpen fEindows(FI,(&flagsLOOKHEAD)&&) {
				//c
	freadag & 0x80) {e(fiindows(FI)tart,h = 米址卸孕慈皇不足8位
 fou右窗口
	>hea&&接掖翱
	< 8)curmatc记指针移动(8S-扔掖翱
f(flag;agsize,size,}#in
		_h米址薪buff	USH+对写入压合并tchftr == fin2
		_h//开始解压hin2,1, rdsizefile	tcount = +;
	- flagsize-sizeof(filesiin2
		_
	fclose(f);
	lo
void LZ77::mergefile(FILE* fout,ULL filesize) {
长度距离对写入压缩文件  
			//先写长度，在写距离。为了和Huffman结合
			UCH chlen = curmatchlength - 3;
			fputc(chlen, fout);//最少是3个，所以用0表示3
			fwrite(&curmatchdist, sizeof(curmatchdist), 1, fout)hlen = curma2chlength - 3;
			fputc(chlen, fout);//最少是3个，所以用0表示3
	}ize_(ize +agsize f, 1, rdsize, f = fo	if ((lookahead <= MIN_Ltart+2], start,hashaddr);
				ze) {
		if (bitcount == 0) {
rt++;
		}ize_对写一while (t(fout);
	FILE* f = fo	if ((lookahead <= MIN_LOOKHEAD)&&(<= MIN_Ltart+2], start,hashaddr);
				ULL encodecount = 0;
	while (ert++;
		}将对写缩文移动到对写buff的起始个数 fo	if ((lookahead <= MIN_LOOKHEAD)&&(LOOKHEAD-<= MIN_Ltart+2], start,hashaddr//开始昙俏皇
			 = 昙俏皇buff;
"LZ77.hin2itcount);
		fputc(WSIZE, fin);
	}#include"LZ77.hitcount);
		fputc(ist),ist, S:end内f;
 fout)hlen = curchlength - 3;
			fputc(chlen, fout);//最少是3个，所以用0表示3
置到右窗口
	if (!fe/读取wsize个数据放置到w* f据放置到}
	FILE* f新哈希表
	_hze -wsize
	f, 1th.c_str(), size
	ze), SEth.c_str(),<, rdsize
	fre
 fou右窗口
	 cutr(), "rbwsize个_END);
	++;
	t,数据的起个8tart,zeofpen fawsize& 0x8tr(), "rbof是ILE, "rb}
	FILE* f_END);
	fr写rfilepath.c_str(), 在}
	FILEfilepaltr == fin2),is
		s得清空/2.验ilepal;
			
	FILE *fo	if (bit
	FILE *f 0) {

	frfilepaistㄎ蝗胙顾跷募 palif ((lahe-
	FILE *fo	tart,hashaddrsize), SE}
	FILE
	fread(//ch为255，因为buff在/2.验郑还没	 = fread(w* f_END);
		_ht; lagsize, sizeof(flagsb}
	FILE, 0 - sizeofpflagsize) - sizeof(files, "rbw* f_END);
	frfilepalagsize, sizeof(flagsth.c_str(),,start,h = pc记指针移动1tart,数据的起, 0 - 3
	tcount = frfile	tcount = ++;
	- flagsize-sizeof(filesi
		_
	fclose(f);
//开始解压"LZ77.hin2,f, 1, rdsize
	fre			fwritepen("4.txt", "wb");ist), 1,t(fout);
	FILE* f = fo置*lflag = 0;los		}
		std:]e
	ze), SEullpthlength(fout)
	USH LE* fin,sflag = 0;
	UCstd:{

	
		_hten f0	 cu
	USH s
		t,lagk(flag;t<fileflag = 0;
	UC
	USH  sizeof(flag;
	FILE*在
	USH 0 - 3
	t<filesiULL encodecount = 0;
	while (eze-sizeoft<filesize) {
		if (bitcount == 0) {
ze-sizeo1);
	fclflag = 0;file	tcount = i
		_
	fclose(f);
ag & 0x80) {			fwrite,h(fout&windows(FI)e) {
将le (mabuff搬移到odecount += matchlen;
			fflush(fout);//所以得清空缓冲区
			fread(&matchdist, sizeof(matchdist), 1, fin1);
			//定位文件指针
			fseek(f, 0-matchdist, SEEK_END);
			while (matchlen) {
				//ch为255，因为数据在缓冲区，还没写入
				ch = fgetc(f);
			f	//原字"(f);.h"= f	//原字iourmeam = f	//原字in);
ch = f	//原字;//libch = fpragma warnE* (E *able:4996s
	(f);
	fclos
		:还没(s		}
		= fge*2]s
		,ad((;//所{
	f(f);
~	fclosh为251);
	fcl还没
		还没los)hlen 		_
	fclose(f);
o
void LZ77::mergefile(FILE* fout,ULL filesize) {
如果(ize +	fseATCH) {
&xt"虿淮b")
		}ize_ze +agsize 			fwrite&curmatchdist, sizeof(curmatchdist), 1, fout)hlen = curmachlength - 3;
			fputc(chlen, fout);//最少是3个，所以用0表示3
	fclose(finf);
}
hashaddrf, 1, rdsize, fftellt = +;of(ize +的指针
 fou, rdsize,(&flags) {
r(), "rh - 3;
			fpu, rd smallfout);//最少是3个，所以用0表示3
	}从0;
	USHt, Sdlib/2.验值buff;
	fclose(finf);
}
SET), 1,t(fout)windows(FILE* fin,shlen;
ch 2 * = fgetc(f);of实际t, S多少鹿希表迦牍size
	//小_pwie 置为0
	//１怼匹配头* f新哈希表
	_hs(FILE*ze
	
	//大于wsin, 0, SEEze
	
	//大于wsize -wsize
	//小t);
	e 置为0
	//读取wsize个数据放置到右窗口
	if (!febool isILE* f_en, lude"LZ7 *hin2itcount);2.lzputc(WSIZE, fin);
	}#include"LZ77.hin2pen("4.txt", "wb");WSIZE, fin);
	}#in
		_h//dlibdlibiles计算的3
	}b")前两ibilatchfor (
	/i	if (/i	_MATCH) {
&&(1; ++ir(), "rad(&∑ヅf	lo(∑ヅ渫白址串i]
		_h米址凶址星位孰
ze), SEindows(FI)curmatc大于wsize -wsize
	bseek(fin, 0, SEEze
	b//1.将
	//压缩
le (
			，并ize_:end头, "rad(& 0;
		//1.将当前字符串插入哈写龋表迦牍取匹配头
		_ht//2.验证在_pwi/2.验证在欠<< ":end	_hten f
	_hs(FIL!cutr(), "rbof<<最长:end,带出SH hashadd, "rbseek(fin, 0, SEElongestek(fi	//1.将当前e;
	FILE *fo迦牍)tart,h = pen faseek(fin, 0, S_MATCH) {
r(), "rbof没<< "e (; i < 迦牍个数压缩r = 0;
	USHilepalagsiz址串插入哈表
ze-sizeo(fout)
	//(files对应的;
	FILE* foutf = fopen("3e,size,右窗口
,_en, sizeo(f++迦牍outf);
	//一个sfile(const std::string & strfilepath) {
	//打开压缩,标记文件指针
	FILE* fin1 = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin1) {
		std::cout << "open false" << std::endl;
		return;
	}
	FILE* fin2 = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin2) {
		std::cout << "open false" << std::endl;
		return;
	}
	//获取源文件大小
	ULL filesize = 0;
	fseek(fin2, 0 - sizeof(filesize), SEEK_END);
	fread(&filesize, sizeof(filesize), 1, fin2);
	//获取标记字节数
	size_t flagsize = 0;
	fseek(fin2, 0 - sizeof(flagsize) - sizeof(filesize), SEEK_END);
	fread(&flagsize, sizeof(flagsize), 1, fin2);
	//将标记指针移动到标记数据的起始位置
	fseek(fin2, 0 - sizeof(flagsize) - flagsize-sizeof(filesize), SEEK_END);
	//开始解压缩
	//写入解压缩数据
	FILE* fout = fopen("4.txt", "wb");
	assert(fout);
	FILE* f = fopen("4.txt", "rb");//读取匹配内容
	if (nullptr == f) {
		std::cout << "open false" << std::endl;
		return;
	}
	UCH bitcount = 0;
	UCH chflag = 0;
	UCH ch = 0;
	UCH matchlen = 0;
	USH matchdist = 0;
	ULL encodecount = 0;
	while (encodecount<filesize) {
		if (bitcount == 0) {
			chflag = fgetc(fin2);
			bitcount = 8;
		}
		if (chflag & 0x80) {
			//是len
			matchlen = fgetc(fin1) + 3;
			encodecount += matchlen;
			fflush(fout);//所以得清空缓冲区
			fread(&matchdist, sizeof(matchdist), 1, fin1);
			//定位文件指针
			fseek(f, 0-matchdist, SEEK_END);
			while (matchlen) {
				//ch为255，因为数据在缓冲区，还没写入
				ch = fgetc(f);
				fputc(ch, fout);
				matchlen--;
			}
		}
		else {
			//原字符
			ch = fgetc(fin1);
			fputc(ch, fout);
			encodecount++;
		}
		chflag <<= 1;
		bitcount--;
	}
	fclose(fin1);
	fclose(fin2);
	fclose(fout);
	fclose(f);
}
void LZ77::mergefile(FILE* fout,ULL filesize) {
	FILE* finf = fopen("3.txt", "rb");
	size_t flagsize = 0;
	UCH* preadbuff = new UCH[1024];
	while (true) {
		size_t rdsize = fread(preadbuff, 1, 1024, finf);
		if (0 == rdsize)
			break;
		fwrite(preadbuff, 1, rdsize, fout);
		flagsize += rdsize;
	}
	fwrite(&flagsize, sizeof(flagsize), 1, fout);
	fwrite(&filesize, sizeof(filesize), 1, fout);
	delete[] preadbuff;
	fclose(finf);
}
void LZ77::fillwindows(FILE* fin,size_t& lookahead){
	//将右窗口数据搬移到左窗口
	memcpy(_pwin, _pwin + WSIZE, WSIZE);

	//更新哈希表
	_ht.update();
	//head prev 中保存的下标
	//大于wsize -wsize
	//小于wsize 置为0
	//读取wsize个数据放置到右窗口
	if (!feof(fin)) {
		lookahead += fread(_pwin + WSIZE, 1, WSIZE, fin);
	}
}
#include"LZ77.h"
#include<iostream>
#include<assert.h>
#include<stdlib.h>
#pragma warning(disable:4996)
LZ77::LZ77()
	:_pwin(new UCH[WSIZE*2])
	,_ht(WSIZE){}
LZ77::~LZ77() {
	delete[] _pwin;
	_pwin = nullptr;
}
void LZ77::compressfile(const std::string & strfilepath) {
	//如果源文件小于MIN_MATCH ，则不处理
	//获取文件大小
	FILE* fin = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin) {
		std::cout << "open false" << std::endl;
		return;
	}
	fseek(fin, 0, SEEK_END);
	ULL filesize = ftell(fin);//源文件的size
	if (filesize <= MIN_MATCH) {
		std::cout << "file small" << std::endl;
		return;
	}
	//从压缩文件读取一个缓冲区的数据
	fseek(fin, 0, SEEK_SET);
	size_t  lookahead = fread(_pwin, 1, 2 * WSIZE, fin);//实际读取多少
	USH start = 0;
	//与查找相关变量
	USH hashaddr = 0;
	USH matchhead = 0;
	USH curmatchlength = 0;
	USH curmatchdist = 0;
	//与写标记相关变量
	UCH chflag = 0;
	UCH bitcount = 0;
	bool islen = false;
	FILE *fout = fopen("2.lzp", "wb");
	assert(fout);
	FILE* foutf = fopen("3.txt", "wb");
	assert(foutf);
	//一个一个字符计算的
	//处理前两个字节
	for (USH i = 0; i < MIN_MATCH - 1; ++i) {
		_ht.hashfunc(hashaddr, _pwin[i]);
	}
	//
	//压缩
	while (lookahead) {
		curmatchdist = 0;
		curmatchlength = 0;
		//1.将当前字符串插入哈希表，并获取匹配头
		_ht.insert(matchhead, _pwin[start + 2],start,hashaddr);
		//2.验证在查找缓冲区中是否找到匹配
		if (matchhead != 0) {
			//找最长匹配,带出长度距离对
			curmatchlength = longestmatch(matchhead, curmatchdist,start);
		}
		if (curmatchlength < MIN_MATCH) {
			//没找到
			//将start位置字符写入压缩文件
			fputc(_pwin[start], fout);
			//写当前原字符对应的标记
			writeflage(foutf,chflag,bitcount,false);
			++start;
			lookahead--;
			
		}
		else {
			//找到了
			//将长度距离对写入压缩文件  
			//先写长度，在写距离。为了和Huffman结合
			UCH chlen = curmatchlength - 3;
			fputc(chlen, fout);//最少是3个，所以用0表示3
			fwrite(&curmatchdist, sizeof(curmatchdist), 1, fout);
			//写标记
			writeflage(foutf, chflag, bitcount, true);
			lookahead -= curmatchlength;//更新先行缓冲区中剩余字节数
			//将已经匹配的字符串按三个一组将其插入到哈希表中
			--curmatchlength;//当前字符串已经插入
			while (curmatchlength) {
				start++;
				_ht.insert(matchhead, _pwin[start+2], start,hashaddr);
				--curmatchlength;
			}
			start++;
		}
		//检测先行缓冲区中剩余字符个数
		if ((lookahead <= MIN_LOOKHEAD)&&(!feof(fin))) {
			fillwindows(fin,lookahead);
		}
	}
	//标记位数不足8位
	if (bitcount > 0 && bitcount < 8) {
		chflag <<= (8 - bitcount);
		fputc(chflag,foutf);
	}
	//将数据文件+标记文件合并
	fflush(foutf);
	mergefile(fout, filesize);
	fclose(fin);
	fclose(fout);
	fclose(foutf);
}
void LZ77::uncompressfile(const std::string & strfilepath) {
	//打开压缩,标记文件指针
	FILE* fin1 = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin1) {
		std::cout << "open false" << std::endl;
		return;
	}
	FILE* fin2 = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin2) {
		std::cout << "open false" << std::endl;
		return;
	}
	//获取源文件大小
	ULL filesize = 0;
	fseek(fin2, 0 - sizeof(filesize), SEEK_END);
	fread(&filesize, sizeof(filesize), 1, fin2);
	//获取标记字节数
	size_t flagsize = 0;
	fseek(fin2, 0 - sizeof(flagsize) - sizeof(filesize), SEEK_END);
	fread(&flagsize, sizeof(flagsize), 1, fin2);
	//将标记指针移动到标记数据的起始位置
	fseek(fin2, 0 - sizeof(flagsize) - flagsize-sizeof(filesize), SEEK_END);
	//开始解压缩
	//写入解压缩数据
	FILE* fout = fopen("4.txt", "wb");
	assert(fout);
	FILE* f = fopen("4.txt", "rb");//读取匹配内容
	if (nullptr == f) {
		std::cout << "open false" << std::endl;
		return;
	}
	UCH bitcount = 0;
	UCH chflag = 0;
	UCH ch = 0;
	UCH matchlen = 0;
	USH matchdist = 0;
	ULL encodecount = 0;
	while (encodecount<filesize) {
		if (bitcount == 0) {
			chflag = fgetc(fin2);
			bitcount = 8;
		}
		if (chflag & 0x80) {
			//是len
			matchlen = fgetc(fin1) + 3;
			encodecount += matchlen;
			fflush(fout);//所以得清空缓冲区
			fread(&matchdist, sizeof(matchdist), 1, fin1);
			//定位文件指针
			fseek(f, 0-matchdist, SEEK_END);
			while (matchlen) {
				//ch为255，因为数据在缓冲区，还没写入
				ch = fgetc(f);
				fputc(ch, fout);
				matchlen--;
			}
		}
		else {
			//原字符
			ch = fgetc(fin1);
			fputc(ch, fout);
			encodecount++;
		}
		chflag <<= 1;
		bitcount--;
	}
	fclose(fin1);
	fclose(fin2);
	fclose(fout);
	fclose(f);
}
void LZ77::mergefile(FILE* fout,ULL filesize) {
	FILE* finf = fopen("3.txt", "rb");
	size_t flagsize = 0;
	UCH* preadbuff = new UCH[1024];
	while (true) {
		size_t rdsize = fread(preadbuff, 1, 1024, finf);
		if (0 == rdsize)
			break;
		fwrite(preadbuff, 1, rdsize, fout);
		flagsize += rdsize;
	}
	fwrite(&flagsize, sizeof(flagsize), 1, fout);
	fwrite(&filesize, sizeof(filesize), 1, fout);
	delete[] preadbuff;
	fclose(finf);
}
void LZ77::fillwindows(FILE* fin,size_t& lookahead){
	//将右窗口数据搬移到左窗口
	memcpy(_pwin, _pwin + WSIZE, WSIZE);

	//更新哈希表
	_ht.update();
	//head prev 中保存的下标
	//大于wsize -wsize
	//小于wsize 置为0
	//读取wsize个数据放置到右窗口
	if (!feof(fin)) {
		lookahead += fread(_pwin + WSIZE, 1, WSIZE, fin);
	}#include"LZ77.h"
#include<iostream>
#include<assert.h>
#include<stdlib.h>
#pragma warning(disable:4996)
LZ77::LZ77()
	:_pwin(new UCH[WSIZE*2])
	,_ht(WSIZE){}
LZ77::~LZ77() {
	delete[] _pwin;
	_pwin = nullptr;
}
void LZ77::compressfile(const std::string & strfilepath) {
	//如果源文件小于MIN_MATCH ，则不处理
	//获取文件大小
	FILE* fin = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin) {
		std::cout << "open false" << std::endl;
		return;
	}
	fseek(fin, 0, SEEK_END);
	ULL filesize = ftell(fin);//源文件的size
	if (filesize <= MIN_MATCH) {
		std::cout << "file small" << std::endl;
		return;
	}
	//从压缩文件读取一个缓冲区的数据
	fseek(fin, 0, SEEK_SET);
	size_t  lookahead = fread(_pwin, 1, 2 * WSIZE, fin);//实际读取多少
	USH start = 0;
	//与查找相关变量
	USH hashaddr = 0;
	USH matchhead = 0;
	USH curmatchlength = 0;
	USH curmatchdist = 0;
	//与写标记相关变量
	UCH chflag = 0;
	UCH bitcount = 0;
	bool islen = false;
	FILE *fout = fopen("2.lzp", "wb");
	assert(fout);
	FILE* foutf = fopen("3.txt", "wb");
	assert(foutf);
	//一个一个字符计算的
	//处理前两个字节
	for (USH i = 0; i < MIN_MATCH - 1; ++i) {
		_ht.hashfunc(hashaddr, _pwin[i]);
	}
	//
	//压缩
	while (lookahead) {
		curmatchdist = 0;
		curmatchlength = 0;
		//1.将当前字符串插入哈希表，并获取匹配头
		_ht.insert(matchhead, _pwin[start + 2],start,hashaddr);
		//2.验证在查找缓冲区中是否找到匹配
		if (matchhead != 0) {
			//找最长匹配,带出长度距离对
			curmatchlength = longestmatch(matchhead, curmatchdist,start);
		}
		if (curmatchlength < MIN_MATCH) {
			//没找到
			//将start位置字符写入压缩文件
			fputc(_pwin[start], fout);
			//写当前原字符对应的标记
			writeflage(foutf,chflag,bitcount,false);
			++start;
			lookahead--;
			
		}
		else {
			//找到了
			//将长度距离对写入压缩文件  
			//先写长度，在写距离。为了和Huffman结合
			UCH chlen = curmatchlength - 3;
			fputc(chlen, fout);//最少是3个，所以用0表示3
			fwrite(&curmatchdist, sizeof(curmatchdist), 1, fout);
			//写标记
			writeflage(foutf, chflag, bitcount, true);
			lookahead -= curmatchlength;//更新先行缓冲区中剩余字节数
			//将已经匹配的字符串按三个一组将其插入到哈希表中
			--curmatchlength;//当前字符串已经插入
			while (curmatchlength) {
				start++;
				_ht.insert(matchhead, _pwin[start+2], start,hashaddr);
				--curmatchlength;
			}
			start++;
		}
		//检测先行缓冲区中剩余字符个数
		if ((lookahead <= MIN_LOOKHEAD)&&(!feof(fin))) {
			fillwindows(fin,lookahead);
		}
	}
	//标记位数不足8位
	if (bitcount > 0 && bitcount < 8) {
		chflag <<= (8 - bitcount);
		fputc(chflag,foutf);
	}
	//将数据文件+标记文件合并
	fflush(foutf);
	mergefile(fout, filesize);
	fclose(fin);
	fclose(fout);
	fclose(foutf);
}
void LZ77::uncompressfile(const std::string & strfilepath) {
	//打开压缩,标记文件指针
	FILE* fin1 = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin1) {
		std::cout << "open false" << std::endl;
		return;
	}
	FILE* fin2 = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin2) {
		std::cout << "open false" << std::endl;
		return;
	}
	//获取源文件大小
	ULL filesize = 0;
	fseek(fin2, 0 - sizeof(filesize), SEEK_END);
	fread(&filesize, sizeof(filesize), 1, fin2);
	//获取标记字节数
	size_t flagsize = 0;
	fseek(fin2, 0 - sizeof(flagsize) - sizeof(filesize), SEEK_END);
	fread(&flagsize, sizeof(flagsize), 1, fin2);
	//将标记指针移动到标记数据的起始位置
	fseek(fin2, 0 - sizeof(flagsize) - flagsize-sizeof(filesize), SEEK_END);
	//开始解压缩
	//写入解压缩数据
	FILE* fout = fopen("4.txt", "wb");
	assert(fout);
	FILE* f = fopen("4.txt", "rb");//读取匹配内容
	if (nullptr == f) {
		std::cout << "open false" << std::endl;
		return;
	}
	UCH bitcount = 0;
	UCH chflag = 0;
	UCH ch = 0;
	UCH matchlen = 0;
	USH matchdist = 0;
	ULL encodecount = 0;
	while (encodecount<filesize) {
		if (bitcount == 0) {
			chflag = fgetc(fin2);
			bitcount = 8;
		}
		if (chflag & 0x80) {
			//是len
			matchlen = fgetc(fin1) + 3;
			encodecount += matchlen;
			fflush(fout);//所以得清空缓冲区
			fread(&matchdist, sizeof(matchdist), 1, fin1);
			//定位文件指针
			fseek(f, 0-matchdist, SEEK_END);
			while (matchlen) {
				//ch为255，因为数据在缓冲区，还没写入
				ch = fgetc(f);
				fputc(ch, fout);
				matchlen--;
			}
		}
		else {
			//原字符
			ch = fgetc(fin1);
			fputc(ch, fout);
			encodecount++;
		}
		chflag <<= 1;
		bitcount--;
	}
	fclose(fin1);
	fclose(fin2);
	fclose(fout);
	fclose(f);
}
void LZ77::mergefile(FILE* fout,ULL filesize) {
	FILE* finf = fopen("3.txt", "rb");
	size_t flagsize = 0;
	UCH* preadbuff = new UCH[1024];
	while (true) {
		size_t rdsize = fread(preadbuff, 1, 1024, finf);
		if (0 == rdsize)
			break;
		fwrite(preadbuff, 1, rdsize, fout);
		flagsize += rdsize;
	}
	fwrite(&flagsize, sizeof(flagsize), 1, fout);
	fwrite(&filesize, sizeof(filesize), 1, fout);
	delete[] preadbuff;
	fclose(finf);
}
void LZ77::fillwindows(FILE* fin,size_t& lookahead){
	//将右窗口数据搬移到左窗口
	memcpy(_pwin, _pwin + WSIZE, WSIZE);

	//更新哈希表
	_ht.update();
	//head prev 中保存的下标
	//大于wsize -wsize
	//小于wsize 置为0
	//读取wsize个数据放置到右窗口
	if (!feof(fin)) {
		lookahead += fread(_pwin + WSIZE, 1, WSIZE, fin);
	}
}
#include"LZ77.h"
#include<iostream>
#include<assert.h>
#include<stdlib.h>
#pragma warning(disable:4996)
LZ77::LZ77()
	:_pwin(new UCH[WSIZE*2])
	,_ht(WSIZE){}
LZ77::~LZ77() {
	delete[] _pwin;
	_pwin = nullptr;
}
void LZ77::compressfile(const std::string & strfilepath) {
	//如果源文件小于MIN_MATCH ，则不处理
	//获取文件大小
	FILE* fin = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin) {
		std::cout << "open false" << std::endl;
		return;
	}
	fseek(fin, 0, SEEK_END);
	ULL filesize = ftell(fin);//源文件的size
	if (filesize <= MIN_MATCH) {
		std::cout << "file small" << std::endl;
		return;
	}
	//从压缩文件读取一个缓冲区的数据
	fseek(fin, 0, SEEK_SET);
	size_t  lookahead = fread(_pwin, 1, 2 * WSIZE, fin);//实际读取多少
	USH start = 0;
	//与查找相关变量
	USH hashaddr = 0;
	USH matchhead = 0;
	USH curmatchlength = 0;
	USH curmatchdist = 0;
	//与写标记相关变量
	UCH chflag = 0;
	UCH bitcount = 0;
	bool islen = false;
	FILE *fout = fopen("2.lzp", "wb");
	assert(fout);
	FILE* foutf = fopen("3.txt", "wb");
	assert(foutf);
	//一个一个字符计算的
	//处理前两个字节
	for (USH i = 0; i < MIN_MATCH - 1; ++i) {
		_ht.hashfunc(hashaddr, _pwin[i]);
	}
	//
	//压缩
	while (lookahead) {
		curmatchdist = 0;
		curmatchlength = 0;
		//1.将当前字符串插入哈希表，并获取匹配头
		_ht.insert(matchhead, _pwin[start + 2],start,hashaddr);
		//2.验证在查找缓冲区中是否找到匹配
		if (matchhead != 0) {
			//找最长匹配,带出长度距离对
			curmatchlength = longestmatch(matchhead, curmatchdist,start);
		}
		if (curmatchlength < MIN_MATCH) {
			//没找到
			//将start位置字符写入压缩文件
			fputc(_pwin[start], fout);
			//写当前原字符对应的标记
			writeflage(foutf,chflag,bitcount,false);
			++start;
			lookahead--;
			
		}
		else {
			//找到了
			//将长度距离对写入压缩文件  
			//先写长度，在写距离。为了和Huffman结合
			UCH chlen = curmatchlength - 3;
			fputc(chlen, fout);//最少是3个，所以用0表示3
			fwrite(&curmatchdist, sizeof(curmatchdist), 1, fout);
			//写标记
			writeflage(foutf, chflag, bitcount, true);
			lookahead -= curmatchlength;//更新先行缓冲区中剩余字节数
			//将已经匹配的字符串按三个一组将其插入到哈希表中
			--curmatchlength;//当前字符串已经插入
			while (curmatchlength) {
				start++;
				_ht.insert(matchhead, _pwin[start+2], start,hashaddr);
				--curmatchlength;
			}
			start++;
		}
		//检测先行缓冲区中剩余字符个数
		if ((lookahead <= MIN_LOOKHEAD)&&(!feof(fin))) {
			fillwindows(fin,lookahead);
		}
	}
	//标记位数不足8位
	if (bitcount > 0 && bitcount < 8) {
		chflag <<= (8 - bitcount);
		fputc(chflag,foutf);
	}
	//将数据文件+标记文件合并
	fflush(foutf);
	mergefile(fout, filesize);
	fclose(fin);
	fclose(fout);
	fclose(foutf);
}
void LZ77::uncompressfile(const std::string & strfilepath) {
	//打开压缩,标记文件指针
	FILE* fin1 = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin1) {
		std::cout << "open false" << std::endl;
		return;
	}
	FILE* fin2 = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin2) {
		std::cout << "open false" << std::endl;
		return;
	}
	//获取源文件大小
	ULL filesize = 0;
	fseek(fin2, 0 - sizeof(filesize), SEEK_END);
	fread(&filesize, sizeof(filesize), 1, fin2);
	//获取标记字节数
	size_t flagsize = 0;
	fseek(fin2, 0 - sizeof(flagsize) - sizeof(filesize), SEEK_END);
	fread(&flagsize, sizeof(flagsize), 1, fin2);
	//将标记指针移动到标记数据的起始位置
	fseek(fin2, 0 - sizeof(flagsize) - flagsize-sizeof(filesize), SEEK_END);
	//开始解压缩
	//写入解压缩数据
	FILE* fout = fopen("4.txt", "wb");
	assert(fout);
	FILE* f = fopen("4.txt", "rb");//读取匹配内容
	if (nullptr == f) {
		std::cout << "open false" << std::endl;
		return;
	}
	UCH bitcount = 0;
	UCH chflag = 0;
	UCH ch = 0;
	UCH matchlen = 0;
	USH matchdist = 0;
	ULL encodecount = 0;
	while (encodecount<filesize) {
		if (bitcount == 0) {
			chflag = fgetc(fin2);
			bitcount = 8;
		}
		if (chflag & 0x80) {
			//是len
			matchlen = fgetc(fin1) + 3;
			encodecount += matchlen;
			fflush(fout);//所以得清空缓冲区
			fread(&matchdist, sizeof(matchdist), 1, fin1);
			//定位文件指针
			fseek(f, 0-matchdist, SEEK_END);
			while (matchlen) {
				//ch为255，因为数据在缓冲区，还没写入
				ch = fgetc(f);
				fputc(ch, fout);
				matchlen--;
			}
		}
		else {
			//原字符
			ch = fgetc(fin1);
			fputc(ch, fout);
			encodecount++;
		}
		chflag <<= 1;
		bitcount--;
	}
	fclose(fin1);
	fclose(fin2);
	fclose(fout);
	fclose(f);
}
void LZ77::mergefile(FILE* fout,ULL filesize) {
	FILE* finf = fopen("3.txt", "rb");
	size_t flagsize = 0;
	UCH* preadbuff = new UCH[1024];
	while (true) {
		size_t rdsize = fread(preadbuff, 1, 1024, finf);
		if (0 == rdsize)
			break;
		fwrite(preadbuff, 1, rdsize, fout);
		flagsize += rdsize;
	}
	fwrite(&flagsize, sizeof(flagsize), 1, fout);
	fwrite(&filesize, sizeof(filesize), 1, fout);
	delete[] preadbuff;
	fclose(finf);
}
void LZ77::fillwindows(FILE* fin,size_t& lookahead){
	//将右窗口数据搬移到左窗口
	memcpy(_pwin, _pwin + WSIZE, WSIZE);

	//更新哈希表
	_ht.update();
	//head prev 中保存的下标
	//大于wsize -wsize
	//小于wsize 置为0
	//读取wsize个数据放置到右窗口
	if (!feof(fin)) {
		lookahead += fread(_pwin + WSIZE, 1, WSIZE, fin);
	}vvv#include"LZ77.h"
#include<iostream>
#include<assert.h>
#include<stdlib.h>
#pragma warning(disable:4996)
LZ77::LZ77()
	:_pwin(new UCH[WSIZE*2])
	,_ht(WSIZE){}
LZ77::~LZ77() {
	delete[] _pwin;
	_pwin = nullptr;
}
void LZ77::compressfile(const std::string & strfilepath) {
	//如果源文件小于MIN_MATCH ，则不处理
	//获取文件大小
	FILE* fin = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin) {
		std::cout << "open false" << std::endl;
		return;
	}
	fseek(fin, 0, SEEK_END);
	ULL filesize = ftell(fin);//源文件的size
	if (filesize <= MIN_MATCH) {
		std::cout << "file small" << std::endl;
		return;
	}
	//从压缩文件读取一个缓冲区的数据
	fseek(fin, 0, SEEK_SET);
	size_t  lookahead = fread(_pwin, 1, 2 * WSIZE, fin);//实际读取多少
	USH start = 0;
	//与查找相关变量
	USH hashaddr = 0;
	USH matchhead = 0;
	USH curmatchlength = 0;
	USH curmatchdist = 0;
	//与写标记相关变量
	UCH chflag = 0;
	UCH bitcount = 0;
	bool islen = false;
	FILE *fout = fopen("2.lzp", "wb");
	assert(fout);
	FILE* foutf = fopen("3.txt", "wb");
	assert(foutf);
	//一个一个字符计算的
	//处理前两个字节
	for (USH i = 0; i < MIN_MATCH - 1; ++i) {
		_ht.hashfunc(hashaddr, _pwin[i]);
	}
	//
	//压缩
	while (lookahead) {
		curmatchdist = 0;
		curmatchlength = 0;
		//1.将当前字符串插入哈希表，并获取匹配头
		_ht.insert(matchhead, _pwin[start + 2],start,hashaddr);
		//2.验证在查找缓冲区中是否找到匹配
		if (matchhead != 0) {
			//找最长匹配,带出长度距离对
			curmatchlength = longestmatch(matchhead, curmatchdist,start);
		}
		if (curmatchlength < MIN_MATCH) {
			//没找到
			//将start位置字符写入压缩文件
			fputc(_pwin[start], fout);
			//写当前原字符对应的标记
			writeflage(foutf,chflag,bitcount,false);
			++start;
			lookahead--;
			
		}
		else {
			//找到了
			//将长度距离对写入压缩文件  
			//先写长度，在写距离。为了和Huffman结合
			UCH chlen = curmatchlength - 3;
			fputc(chlen, fout);//最少是3个，所以用0表示3
			fwrite(&curmatchdist, sizeof(curmatchdist), 1, fout);
			//写标记
			writeflage(foutf, chflag, bitcount, true);
			lookahead -= curmatchlength;//更新先行缓冲区中剩余字节数
			//将已经匹配的字符串按三个一组将其插入到哈希表中
			--curmatchlength;//当前字符串已经插入
			while (curmatchlength) {
				start++;
				_ht.insert(matchhead, _pwin[start+2], start,hashaddr);
				--curmatchlength;
			}
			start++;
		}
		//检测先行缓冲区中剩余字符个数
		if ((lookahead <= MIN_LOOKHEAD)&&(!feof(fin))) {
			fillwindows(fin,lookahead);
		}
	}
	//标记位数不足8位
	if (bitcount > 0 && bitcount < 8) {
		chflag <<= (8 - bitcount);
		fputc(chflag,foutf);
	}
	//将数据文件+标记文件合并
	fflush(foutf);
	mergefile(fout, filesize);
	fclose(fin);
	fclose(fout);
	fclose(foutf);
}
void LZ77::uncompressfile(const std::string & strfilepath) {
	//打开压缩,标记文件指针
	FILE* fin1 = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin1) {
		std::cout << "open false" << std::endl;
		return;
	}
	FILE* fin2 = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin2) {
		std::cout << "open false" << std::endl;
		return;
	}
	//获取源文件大小
	ULL filesize = 0;
	fseek(fin2, 0 - sizeof(filesize), SEEK_END);
	fread(&filesize, sizeof(filesize), 1, fin2);
	//获取标记字节数
	size_t flagsize = 0;
	fseek(fin2, 0 - sizeof(flagsize) - sizeof(filesize), SEEK_END);
	fread(&flagsize, sizeof(flagsize), 1, fin2);
	//将标记指针移动到标记数据的起始位置
	fseek(fin2, 0 - sizeof(flagsize) - flagsize-sizeof(filesize), SEEK_END);
	//开始解压缩
	//写入解压缩数据
	FILE* fout = fopen("4.txt", "wb");
	assert(fout);
	FILE* f = fopen("4.txt", "rb");//读取匹配内容
	if (nullptr == f) {
		std::cout << "open false" << std::endl;
		return;
	}
	UCH bitcount = 0;
	UCH chflag = 0;
	UCH ch = 0;
	UCH matchlen = 0;
	USH matchdist = 0;
	ULL encodecount = 0;
	while (encodecount<filesize) {
		if (bitcount == 0) {
			chflag = fgetc(fin2);
			bitcount = 8;
		}
		if (chflag & 0x80) {
			//是len
			matchlen = fgetc(fin1) + 3;
			encodecount += matchlen;
			fflush(fout);//所以得清空缓冲区
			fread(&matchdist, sizeof(matchdist), 1, fin1);
			//定位文件指针
			fseek(f, 0-matchdist, SEEK_END);
			while (matchlen) {
				//ch为255，因为数据在缓冲区，还没写入
				ch = fgetc(f);
				fputc(ch, fout);
				matchlen--;
			}
		}
		else {
			//原字符
			ch = fgetc(fin1);
			fputc(ch, fout);
			encodecount++;
		}
		chflag <<= 1;
		bitcount--;
	}
	fclose(fin1);
	fclose(fin2);
	fclose(fout);
	fclose(f);
}
void LZ77::mergefile(FILE* fout,ULL filesize) {
	FILE* finf = fopen("3.txt", "rb");
	size_t flagsize = 0;
	UCH* preadbuff = new UCH[1024];
	while (true) {
		size_t rdsize = fread(preadbuff, 1, 1024, finf);
		if (0 == rdsize)
			break;
		fwrite(preadbuff, 1, rdsize, fout);
		flagsize += rdsize;
	}
	fwrite(&flagsize, sizeof(flagsize), 1, fout);
	fwrite(&filesize, sizeof(filesize), 1, fout);
	delete[] preadbuff;
	fclose(finf);
}
void LZ77::fillwindows(FILE* fin,size_t& lookahead){
	//将右窗口数据搬移到左窗口
	memcpy(_pwin, _pwin + WSIZE, WSIZE);

	//更新哈希表
	_ht.update();
	//head prev 中保存的下标
	//大于wsize -wsize
	//小于wsize 置为0
	//读取wsize个数据放置到右窗口
	if (!feof(fin)) {
		lookahead += fread(_pwin + WSIZE, 1, WSIZE, fin);
	}
}
#include"LZ77.h"
#include<iostream>
#include<assert.h>
#include<stdlib.h>
#pragma warning(disable:4996)
LZ77::LZ77()
	:_pwin(new UCH[WSIZE*2])
	,_ht(WSIZE){}
LZ77::~LZ77() {
	delete[] _pwin;
	_pwin = nullptr;
}
void LZ77::compressfile(const std::string & strfilepath) {
	//如果源文件小于MIN_MATCH ，则不处理
	//获取文件大小
	FILE* fin = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin) {
		std::cout << "open false" << std::endl;
		return;
	}
	fseek(fin, 0, SEEK_END);
	ULL filesize = ftell(fin);//源文件的size
	if (filesize <= MIN_MATCH) {
		std::cout << "file small" << std::endl;
		return;
	}
	//从压缩文件读取一个缓冲区的数据
	fseek(fin, 0, SEEK_SET);
	size_t  lookahead = fread(_pwin, 1, 2 * WSIZE, fin);//实际读取多少
	USH start = 0;
	//与查找相关变量
	USH hashaddr = 0;
	USH matchhead = 0;
	USH curmatchlength = 0;
	USH curmatchdist = 0;
	//与写标记相关变量
	UCH chflag = 0;
	UCH bitcount = 0;
	bool islen = false;
	FILE *fout = fopen("2.lzp", "wb");
	assert(fout);
	FILE* foutf = fopen("3.txt", "wb");
	assert(foutf);
	//一个一个字符计算的
	//处理前两个字节
	for (USH i = 0; i < MIN_MATCH - 1; ++i) {
		_ht.hashfunc(hashaddr, _pwin[i]);
	}
	//
	//压缩
	while (lookahead) {
		curmatchdist = 0;
		curmatchlength = 0;
		//1.将当前字符串插入哈希表，并获取匹配头
		_ht.insert(matchhead, _pwin[start + 2],start,hashaddr);
		//2.验证在查找缓冲区中是否找到匹配
		if (matchhead != 0) {
			//找最长匹配,带出长度距离对
			curmatchlength = longestmatch(matchhead, curmatchdist,start);
		}
		if (curmatchlength < MIN_MATCH) {
			//没找到
			//将start位置字符写入压缩文件
			fputc(_pwin[start], fout);
			//写当前原字符对应的标记
			writeflage(foutf,chflag,bitcount,false);
			++start;
			lookahead--;
			
		}
		else {
			//找到了
			//将长度距离对写入压缩文件  
			//先写长度，在写距离。为了和Huffman结合
			UCH chlen = curmatchlength - 3;
			fputc(chlen, fout);//最少是3个，所以用0表示3
			fwrite(&curmatchdist, sizeof(curmatchdist), 1, fout);
			//写标记
			writeflage(foutf, chflag, bitcount, true);
			lookahead -= curmatchlength;//更新先行缓冲区中剩余字节数
			//将已经匹配的字符串按三个一组将其插入到哈希表中
			--curmatchlength;//当前字符串已经插入
			while (curmatchlength) {
				start++;
				_ht.insert(matchhead, _pwin[start+2], start,hashaddr);
				--curmatchlength;
			}
			start++;
		}
		//检测先行缓冲区中剩余字符个数
		if ((lookahead <= MIN_LOOKHEAD)&&(!feof(fin))) {
			fillwindows(fin,lookahead);
		}
	}
	//标记位数不足8位
	if (bitcount > 0 && bitcount < 8) {
		chflag <<= (8 - bitcount);
		fputc(chflag,foutf);
	}
	//将数据文件+标记文件合并
	fflush(foutf);
	mergefile(fout, filesize);
	fclose(fin);
	fclose(fout);
	fclose(foutf);
}
void LZ77::uncompressfile(const std::string & strfilepath) {
	//打开压缩,标记文件指针
	FILE* fin1 = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin1) {
		std::cout << "open false" << std::endl;
		return;
	}
	FILE* fin2 = fopen(strfilepath.c_str(), "rb");
	if (nullptr == fin2) {
		std::cout << "open false" << std::endl;
		return;
	}
	//获取源文件大小
	ULL filesize = 0;
	fseek(fin2, 0 - sizeof(filesize), SEEK_END);
	fread(&filesize, sizeof(filesize), 1, fin2);
	//获取标记字节数
	size_t flagsize = 0;
	fseek(fin2, 0 - sizeof(flagsize) - sizeof(filesize), SEEK_END);
	fread(&flagsize, sizeof(flagsize), 1, fin2);
	//将标记指针移动到标记数据的起始位置
	fseek(fin2, 0 - sizeof(flagsize) - flagsize-sizeof(filesize), SEEK_END);
	//开始解压缩
	//写入解压缩数据
	FILE* fout = fopen("4.txt", "wb");
	assert(fout);
	FILE* f = fopen("4.txt", "rb");//读取匹配内容
	if (nullptr == f) {
		std::cout << "open false" << std::endl;
		return;
	}
	UCH bitcount = 0;
	UCH chflag = 0;
	UCH ch = 0;
	UCH matchlen = 0;
	USH matchdist = 0;
	ULL encodecount = 0;
	while (encodecount<filesize) {
		if (bitcount == 0) {
			chflag = fgetc(fin2);
			bitcount = 8;
		}
		if (chflag & 0x80) {
			//是len
			matchlen = fgetc(fin1) + 3;
			encodecount += matchlen;
			fflush(fout);//所以得清空缓冲区
			fread(&matchdist, sizeof(matchdist), 1, fin1);
			//定位文件指针
			fseek(f, 0-matchdist, SEEK_END);
			while (matchlen) {
				//ch为255，因为数据在缓冲区，还没写入
				ch = fgetc(f);
				fputc(ch, fout);
				matchlen--;
			}
		}
		else {
			//原字符
			ch = fgetc(fin1);
			fputc(ch, fout);
			encodecount++;
		}
		chflag <<= 1;
		bitcount--;
	}
	fclose(fin1);
	fclose(fin2);
	fclose(fout);
	fclose(f);
}
void LZ77::mergefile(FILE* fout,ULL filesize) {
	FILE* finf = fopen("3.txt", "rb");
	size_t flagsize = 0;
	UCH* preadbuff = new UCH[1024];
	while (true) {
		size_t rdsize = fread(preadbuff, 1, 1024, finf);
		if (0 == rdsize)
			break;
		fwrite(preadbuff, 1, rdsize, fout);
		flagsize += rdsize;
	}
	fwrite(&flagsize, sizeof(flagsize), 1, fout);
	fwrite(&filesize, sizeof(filesize), 1, fout);
	delete[] preadbuff;
	fclose(finf);
}
void LZ77::fillwindows(FILE* fin,size_t& lookahead){
	//将右窗口数据搬移到左窗口
	memcpy(_pwin, _pwin + WSIZE, WSIZE);

	//更新哈希表
	_ht.update();
	//head prev 中保存的下标
	//大于wsize -wsize
	//小于wsize 置为0
	//读取wsize个数据放置到右窗口
	if (!feof(fin)) {
		lookahead += fread(_pwin + WSIZE, 1, WSIZE, fin);
	}